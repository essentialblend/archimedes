accelerate	Param	Sound.Tidal.Params	Control parameter	A pattern of numbers that speed up (or slow down) samples while they play. In the following example, the sound starts at the original pitch and gets higher as it plays: > d1 $ s "arpy" # accelerate 2 You can use a negative number to make the sound get lower. In this example, a different acceleration is applied to each played note using state values: > d1 $ arp "up" $ note "c'maj'4" # s "arpy" # accelerateTake "susan" [0.2,1,-1]
all	Boot	Sound.Tidal.Boot	(Tidally) => (ControlPattern -> ControlPattern) -> IO ()	See 'Sound.Tidal.Stream.streamAll'.
almostAlways	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	almostAlways is an alias for 'sometimesBy' 0.9.
almostAlways'	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	almostAlways' is an alias for 'sometimesBy'' 0.9.
almostNever	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	almostNever is an alias for 'sometimesBy' 0.1.
almostNever'	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	almostNever' is an alias for 'sometimesBy'' 0.1.
always	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	Apply the transformation to the pattern unconditionally. always = id
amp	Param	Sound.Tidal.Params	Control parameter	Controls the amplitude (volume) of the sound. Like 'gain', but linear. Default value is 0.4. > d1 $ s "arpy" # amp "<0.4 0.8 0.2>"
anticipate	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	
anticipateIn	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
append	Function	Sound.Tidal.Core	Pattern a -> Pattern a -> Pattern a	Alternate between cycles of the two given patterns > d1 $ append (sound "bd*2 sn") (sound "arpy jvbass*2")
arp	Function	Sound.Tidal.UI	Pattern String -> Pattern a -> Pattern a	The arp function takes an additional pattern of arpeggiate modes. For example: d1 $ sound "superpiano" # n (arp "<up down diverge>" "<a'm9'8 e'7sus4'8>") The different arpeggiate modes are: up down updown downup up&down down&up converge diverge disconverge pinkyup pinkyupdown thumbup thumbupdown
arpeggiate	Function	Sound.Tidal.UI	Pattern a -> Pattern a	arpeggiate finds events that share the same timespan, and spreads them out during that timespan, so for example arpeggiate "[bd,sn]" gets turned into "bd sn". Useful for creating arpeggios/broken chords.
arpg	Function	Sound.Tidal.UI	Pattern a -> Pattern a	Shorthand alias for arpeggiate
arps	Function	Sound.Tidal.UI	[(String, [a] -> [a])]	
arpWith	Function	Sound.Tidal.UI	([EventF (ArcF Time) a] -> [EventF (ArcF Time) b]) -> Pattern a -> Pattern b	
arrange	Function	Sound.Tidal.Core	Time -> [(Time, Pattern a)] -> [(Time, Time, Pattern a)]	
array	Param	Sound.Tidal.Params	Control parameter	
asap	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	An alias for 'once'.
ascii	Function	Sound.Tidal.UI	Pattern String -> Pattern Bool	
att	Param	Sound.Tidal.Params	Control parameter	
attack	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers to specify the attack time (in seconds) of an envelope applied to each sample.
bandf	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the center frequency of the band-pass filter.
bandq	Param	Sound.Tidal.Params	Control parameter	a pattern of anumbers from 0 to 1. Sets the q-factor of the band-pass filter.
bank	Param	Sound.Tidal.Params	Control parameter	A pattern of strings. When sent to SuperDirt, will be prepended to sample folder names, separated by an underscore. This allows sample sets to be organised into separate banks. See https://github.com/musikinformatik/SuperDirt/pull/312
beat	Function	Sound.Tidal.UI	Pattern Time -> Pattern Time -> Pattern a -> Pattern a	beat structures a pattern by picking subdivisions of a cycle. Takes in a pattern that tells it which parts to play (polyphony is recommeded here), and the number of parts by which to subdivide the cycle (also pattern-able). For example: > d1 $ beat "[3,4.2,9,11,14]" 16 $ s "sd"
begin	Param	Sound.Tidal.Params	Control parameter	begin receives a pattern of numbers from 0 to 1 and skips the beginning of each sample by the indicated proportion. I.e., 0 would play the sample from the start, 1 would skip the whole sample, and 0.25 would cut off the first quarter. In this example, the first 3 ade samples are played on every cycle, but the start point from which they are played changes on each cycle: > d1 $ n "0 1 2" # s "ade" # begin "<0 0.25 0.5 0.75>" # legato 1
binary	Function	Sound.Tidal.UI	Pattern Int -> Pattern Bool	
binaryN	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern Bool	
binshift	Param	Sound.Tidal.Params	Control parameter	Spectral binshift
bite	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern a -> Pattern a	bite n ipat pat slices a pattern pat into n pieces, then uses the ipat pattern of integers to index into those slices. So bite 4 "0 2*2" (run 8) is the same as "[0 1] [4 5]*2". I.e., it allows you to slice each cycle into a given number of equal sized bits, and then pattern those bits by number. It’s similar to slice, but is for slicing up patterns, rather than samples. The following slices the pattern into four bits, and then plays those bits in turn: > d1 $ bite 4 "0 1 2 3" $ n "0 .. 7" # sound "arpy" Of course that doesn’t actually change anything, but then you can reorder those bits: > d1 $ bite 4 "2 0 1 3" $ n "0 .. 7" # sound "arpy" The slices bits of pattern will be squeezed or contracted to fit: > d1 $ bite 4 "2 [0 3] 1*4 1" $ n "0 .. 7" # sound "arpy"
bpf	Param	Sound.Tidal.Params	Control parameter	
bpq	Param	Sound.Tidal.Params	Control parameter	
brak	Function	Sound.Tidal.UI	Pattern a -> Pattern a	brak makes a pattern sound a bit like a breakbeat. It does this by, every other cycle, squashing the pattern to fit half a cycle, and offsetting it by a quarter of a cycle. d1 $ sound (brak "bd sn kurt") d1 $ brak $ sound "[feel feel:3, hc:3 hc:2 hc:4 ho:1]"
brand	Function	Sound.Tidal.UI	Pattern Bool	Boolean rand - a continuous stream of true\/false values, with a 50\/50 chance.
brandBy	Function	Sound.Tidal.UI	Pattern Double -> Pattern Bool	Boolean rand with probability as input, e.g. brandBy 0.25 produces trues 25% of the time.
button0	Param	Sound.Tidal.Params	Control parameter	
button1	Param	Sound.Tidal.Params	Control parameter	
button10	Param	Sound.Tidal.Params	Control parameter	
button11	Param	Sound.Tidal.Params	Control parameter	
button12	Param	Sound.Tidal.Params	Control parameter	
button13	Param	Sound.Tidal.Params	Control parameter	
button14	Param	Sound.Tidal.Params	Control parameter	
button15	Param	Sound.Tidal.Params	Control parameter	
button2	Param	Sound.Tidal.Params	Control parameter	
button3	Param	Sound.Tidal.Params	Control parameter	
button4	Param	Sound.Tidal.Params	Control parameter	
button5	Param	Sound.Tidal.Params	Control parameter	
button6	Param	Sound.Tidal.Params	Control parameter	
button7	Param	Sound.Tidal.Params	Control parameter	
button8	Param	Sound.Tidal.Params	Control parameter	
button9	Param	Sound.Tidal.Params	Control parameter	
cat	Function	Sound.Tidal.Core	[Pattern a] -> Pattern a	Like 'append', but for a list of patterns. Interlaces them, playing the first cycle from each in turn, then the second cycle from each, and so on. It concatenates a list of patterns into a new pattern; each pattern in the list will maintain its original duration. For example: > d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2"] > d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"] > d1 $ cat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]
cB	Function	Sound.Tidal.Core	Bool -> String -> Pattern Bool	
cB_	Function	Sound.Tidal.Core	String -> Pattern Bool	
cB0	Function	Sound.Tidal.Core	String -> Pattern Bool	
cc	Param	Sound.Tidal.Params	Control parameter	
ccn	Param	Sound.Tidal.Params	Control parameter	
ccv	Param	Sound.Tidal.Params	Control parameter	
cF	Function	Sound.Tidal.Core	Double -> String -> Pattern Double	
cF_	Function	Sound.Tidal.Core	String -> Pattern Double	
cF0	Function	Sound.Tidal.Core	String -> Pattern Double	
channel	Param	Sound.Tidal.Params	Control parameter	choose the channel the pattern is sent to in superdirt
chdecay	Param	Sound.Tidal.Params	Control parameter	
chew	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> ControlPattern -> ControlPattern	TODO maybe _chew could pattern the first parameter directly..
choose	Function	Sound.Tidal.UI	[a] -> Pattern a	Randomly picks an element from the given list. sound "superpiano(3,8)" # note (choose ["a", "e", "g", "c"]) plays a melody randomly choosing one of the four notes \"a\", \"e\", \"g\", \"c\". As with all continuous patterns, you have to be careful to give them structure; in this case choose gives you an infinitely detailed stream of random choices. > choose = 'chooseBy' 'rand'
chooseBy	Function	Sound.Tidal.UI	Pattern Double -> [a] -> Pattern a	Given a pattern of doubles, chooseBy normalizes them so that each corresponds to an index in the provided list. The returned pattern contains the corresponding elements in the list. It is like choose, but instead of selecting elements of the list randomly, it uses the given pattern to select elements. 'choose' = chooseBy 'rand' The following results in the pattern "a b c": > chooseBy "0 0.25 0.5" ["a","b","c","d"]
chromaticiseBy	Function	Sound.Tidal.UI	(Num a, Enum a, Ord a) => Pattern a -> Pattern a -> Pattern a	Inserts chromatic notes into a pattern. The first argument indicates the (patternable) number of notes to insert, and the second argument is the base pattern of "anchor notes" that gets transformed. The following are equivalent: > d1 $ up (chromaticiseBy "0 1 2 -1" "[0 2] [3 6] [5 6 8] [3 1 0]") # s "superpiano" > d1 $ up "[0 2] [[3 4] [6 7]] [[5 6 7] [6 7 8] [8 9 10] [[3 2] [1 0] [0 -1]]" # s "superpiano"
chromaticizeBy	Function	Sound.Tidal.UI	(Num a, Enum a, Ord a) => Pattern a -> Pattern a -> Pattern a	Alias for chromaticiseBy
chunk	Function	Sound.Tidal.UI	Pattern Int -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b	Treats the given pattern p as having n chunks, and applies the function f to one of those sections per cycle. Running: - from left to right if chunk number is positive - from right to left if chunk number is negative > d1 $ chunk 4 (fast 4) $ sound "cp sn arpy [mt lt]" The following: > d1 $ chunk 4 (# speed 2) $ sound "bd hh sn cp" applies (# speed 2) to the uppercased part of the cycle below: > BD hh sn cp > bd HH sn cp > bd hh SN cp > bd hh sn CP
chunk'	Function	Sound.Tidal.UI	(Integral a1) => Pattern a1 -> (Pattern a2 -> Pattern a2) -> Pattern a2 -> Pattern a2	DEPRECATED, use 'chunk' with negative numbers instead
cI	Function	Sound.Tidal.Core	Int -> String -> Pattern Int	
cI_	Function	Sound.Tidal.Core	String -> Pattern Int	
cI0	Function	Sound.Tidal.Core	String -> Pattern Int	
clhatdecay	Param	Sound.Tidal.Params	Control parameter	
clip	Param	Sound.Tidal.Params	Control parameter	
clutch	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	
clutchIn	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
cN	Function	Sound.Tidal.Core	Note -> String -> Pattern Note	
cN_	Function	Sound.Tidal.Core	String -> Pattern Note	
cN0	Function	Sound.Tidal.Core	String -> Pattern Note	
coarse	Param	Sound.Tidal.Params	Control parameter	fake-resampling, a pattern of numbers for lowering the sample rate, i.e. 1 for original 2 for half, 3 for a third and so on.
comb	Param	Sound.Tidal.Params	Control parameter	Spectral comb
compress	Function	Sound.Tidal.Core	(Time, Time) -> Pattern a -> Pattern a	compress takes a pattern and squeezes it within the specified time span (i.e. the ‘arc’). The new resulting pattern is a sped up version of the original. > d1 $ compress (1/4, 3/4) $ s "[bd sn]!" In the above example, the pattern will play in an arc spanning from 25% to 75% of the duration of a cycle. It is equivalent to: > d1 $ s "~ [bd sn]! ~" Another example, where all events are different: > d1 $ compress (1/4, 3/4) $ n (run 4) # s "arpy" It differs from 'zoom' in that it preserves the original pattern but it speeds up its events so to match with the new time period.
compressTo	Function	Sound.Tidal.Core	(Time, Time) -> Pattern a -> Pattern a	
constrainEvent	Function	Sound.Tidal.UI	Arc -> Event a -> Maybe (Event a)	
constrainEvents	Function	Sound.Tidal.UI	Arc -> [Event a] -> [Event a]	
constrainPart	Function	Sound.Tidal.Core	Event a -> Maybe (Event a)	
control	Param	Sound.Tidal.Params	Control parameter	
cosine	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	cosine - unipolar cosine wave. A pattern of continuous values following a cosine with frequency of one cycle, and amplitude from 0 to 1. Equivalent to 0.25 ~> sine.
cosine2	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	cosine2 - bipolar cosine wave. A pattern of continuous values following a cosine with frequency of one cycle, and amplitude from -1 to 1. Equivalent to 0.25 ~> sine2.
cps	Param	Sound.Tidal.Params	Control parameter	A control pattern; 'setcps' is the standalone function. Patterns don’t (yet) have independent tempos though, if you change it on one pattern, it changes on all of them. > p "cpsfun" $ s "bd sd(3,8)" # cps (slow 8 $ 0.5 + saw)
cR	Function	Sound.Tidal.Core	Rational -> String -> Pattern Rational	
cR_	Function	Sound.Tidal.Core	String -> Pattern Rational	
cR0	Function	Sound.Tidal.Core	String -> Pattern Rational	
crush	Param	Sound.Tidal.Params	Control parameter	bit crushing, a pattern of numbers from 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).
cS	Function	Sound.Tidal.Core	String -> String -> Pattern String	
cS_	Function	Sound.Tidal.Core	String -> Pattern String	
cS0	Function	Sound.Tidal.Core	String -> Pattern String	
cT	Function	Sound.Tidal.Core	Time -> String -> Pattern Time	
cT_	Function	Sound.Tidal.Core	String -> Pattern Time	
cT0	Function	Sound.Tidal.Core	String -> Pattern Time	
ctf	Param	Sound.Tidal.Params	Control parameter	
ctfg	Param	Sound.Tidal.Params	Control parameter	
ctlNum	Param	Sound.Tidal.Params	Control parameter	
ctranspose	Param	Sound.Tidal.Params	Control parameter	
cut	Param	Sound.Tidal.Params	Control parameter	In the style of classic drum-machines, `cut` will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.
cutoff	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers in Hz. Applies the cutoff frequency of the low-pass filter.
cutoffegint	Param	Sound.Tidal.Params	Control parameter	
cycleChoose	Function	Sound.Tidal.UI	[a] -> Pattern a	cycleChoose is like `choose` but only picks a new item from the list once each cycle. > d1 $ sound "drum ~ drum drum" # n (cycleChoose [0,2,3])
d1	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d1_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d10	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d10_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d11	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d11_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d12	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d12_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d13	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d13_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d14	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d14_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d15	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d15_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d16	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d16_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d2	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d2_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d3	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d3_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d4	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d4_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d5	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d5_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d6	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d6_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d7	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d7_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d8	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d8_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
d9	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Replace what's playing on the given orbit.
d9_	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	Rapidly silence what's playing on the given orbit
decay	Param	Sound.Tidal.Params	Control parameter	
deconstruct	Function	Sound.Tidal.UI	Int -> Pattern String -> String	construct n p breaks p into pieces and then reassembles them so that it fits into n steps.
degrade	Function	Sound.Tidal.UI	Pattern a -> Pattern a	degrade randomly removes events from a pattern 50% of the time: > d1 $ slow 2 $ degrade $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]" > # accelerate "-6" > # speed "2" The shorthand syntax for degrade is a question mark: ?. Using ? will allow you to randomly remove events from a portion of a pattern: > d1 $ slow 2 $ sound "bd ~ sn bd ~ bd? [sn bd?] ~" You can also use ? to randomly remove events from entire sub-patterns: > d1 $ slow 2 $ sound "[[[feel:5*8,feel*3] feel:3*8]?, feel*4]"
degradeBy	Function	Sound.Tidal.UI	Pattern Double -> Pattern a -> Pattern a	Similar to `degrade`, degradeBy allows you to control the percentage of events that are removed. For example, to remove events 90% of the time: d1 $ slow 2 $ degradeBy 0.9 $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]" # accelerate "-6" # speed "2" You can also invoke this behavior in the shorthand notation by specifying a percentage, as a number between 0 and 1, after the question mark: d1 $ s "bd hh?0.8 bd hh?0.4"
degradeOverBy	Function	Sound.Tidal.UI	Int -> Pattern Double -> Pattern a -> Pattern a	
degree	Param	Sound.Tidal.Params	Control parameter	
delay	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the level of the delay signal.
delayfb	Param	Sound.Tidal.Params	Control parameter	
delayfeedback	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the amount of delay feedback.
delayt	Param	Sound.Tidal.Params	Control parameter	
delaytime	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the length of the delay.
densityGap	Function	Sound.Tidal.Core	Pattern Time -> Pattern a -> Pattern a	An alias for fastGap
det	Param	Sound.Tidal.Params	Control parameter	
detune	Param	Sound.Tidal.Params	Control parameter	
dfb	Param	Sound.Tidal.Params	Control parameter	
disableLink	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	
discretise	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	discretise: the old (deprecated) name for 'segment'
distort	Param	Sound.Tidal.Params	Control parameter	noisy fuzzy distortion
distrib	Function	Sound.Tidal.UI	[Pattern Int] -> Pattern a -> Pattern a	
distrib'	Function	Sound.Tidal.UI	[Bool] -> [Bool] -> [Bool]	
djf	Param	Sound.Tidal.Params	Control parameter	DJ filter, below 0.5 is low pass filter, above is high pass filter.
dry	Param	Sound.Tidal.Params	Control parameter	when set to `1` will disable all reverb for this pattern. See `room` and `size` for more information about reverb.
dt	Param	Sound.Tidal.Params	Control parameter	
dur	Param	Sound.Tidal.Params	Control parameter	
enableLink	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	
enclosingArc	Function	Sound.Tidal.UI	[Arc] -> Arc	TODO: refactor towards union
end	Param	Sound.Tidal.Params	Control parameter	Similar to `begin`, but cuts the end off samples, shortening them; e.g. 0.75 to cut off the last quarter of each sample. > d1 $ s "bev" >| begin 0.5 >| end "[0.65 0.55]" The example above will play the sample two times for cycle, but the second time will play a shorter segment than the first time, creating a kind of canon effect.
enhance	Param	Sound.Tidal.Params	Control parameter	Spectral enhance
envEq	Function	Sound.Tidal.Core	Pattern Double	'Equal power' version of 'env', for gain-based transitions
envEqR	Function	Sound.Tidal.Core	Pattern Double	Equal power reversed
envL	Function	Sound.Tidal.Core	Pattern Double	envL is a 'Pattern' of continuous 'Double' values, representing a linear interpolation between 0 and 1 during the first cycle, then staying constant at 1 for all following cycles. Possibly only useful if you're using something like the retrig function defined in tidal.el.
envLR	Function	Sound.Tidal.Core	Pattern Double	like 'envL' but reversed.
eoff	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a	A shorter alias for 'euclidOff'.
euclid	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern a -> Pattern a	You can use the euclid function to apply a Euclidean algorithm over a complex pattern, although the structure of that pattern will be lost: > d1 $ euclid 3 8 $ sound "bd*2 [sn cp]" In the above, three sounds are picked from the pattern on the right according to the structure given by the euclid 3 8. It ends up picking two bd sounds, a cp and missing the sn entirely. A negative first argument provides the inverse of the euclidean pattern. These types of sequences use "Bjorklund's algorithm", which wasn't made for music but for an application in nuclear physics, which is exciting. More exciting still is that it is very similar in structure to the one of the first known algorithms written in Euclid's book of elements in 300 BC. You can read more about this in the paper [The Euclidean Algorithm Generates Traditional Musical Rhythms](http://cgm.cs.mcgill.ca/~godfried/publications/banff.pdf) by Toussaint. Some examples from this paper are included below, including rotation as a third parameter in some cases (see 'euclidOff'). Pattern | Example | (2,5) | A thirteenth century Persian rhythm called Khafif-e-ramal. | (3,4) | The archetypal pattern of the Cumbia from Colombia, as well as | | a Calypso rhythm from Trinidad. | (3,5,2) | Another thirteenth century Persian rhythm by the name of | | Khafif-e-ramal, as well as a Rumanian folk-dance rhythm. | (3,7) | A Ruchenitza rhythm used in a Bulgarian folk-dance. | (3,8) | The Cuban tresillo pattern. | (4,7) | Another Ruchenitza Bulgarian folk-dance rhythm. | (4,9) | The Aksak rhythm of Turkey. | (4,11) | The metric pattern used by Frank Zappa in his piece titled | | Outside Now. | (5,6) | Yields the York-Samai pattern, a popular Arab rhythm. | (5,7) | The Nawakhat pattern, another popular Arab rhythm. | (5,8) | The Cuban cinquillo pattern. | (5,9) | A popular Arab rhythm called Agsag-Samai. | (5,11) | The metric pattern used by Moussorgsky in | | Pictures at an Exhibition. | (5,12) | The Venda clapping pattern of a South African children’s song. | (5,16) | The Bossa-Nova rhythm necklace of Brazil. | (7,8) | A typical rhythm played on the Bendir (frame drum). | (7,12) | A common West African bell pattern. | (7,16,14) | A Samba rhythm necklace from Brazil. | (9,16) | A rhythm necklace used in the Central African Republic. | (11,24,14) | A rhythm necklace of the Aka Pygmies of Central Africa. | (13,24,5) | Another rhythm necklace of the Aka Pygmies of the upper Sangha. | There was once a shorter alias e for this function. It has been removed, but you may see references to it in older Tidal code.
euclidFull	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern a -> Pattern a -> Pattern a	euclidFull n k pa pb stacks 'euclid' n k pa with 'euclidInv' n k pb. That is, it plays one pattern on the euclidean rhythm and a different pattern on the off-beat. For example, to implement the traditional flamenco rhythm, you could use hard claps for the former and soft claps for the latter: > d1 $ euclidFull 3 7 "realclaps" ("realclaps" # gain 0.8)
euclidInv	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern a -> Pattern a	euclidInv fills in the blanks left by `euclid`, i.e., it inverts the pattern. For example, whereas euclid 3 8 "x" produces > "x ~ ~ x ~ ~ x ~" euclidInv 3 8 "x" produces > "~ x x ~ x x ~ x" As another example, in > d1 $ stack [ euclid 5 8 $ s "bd" > , euclidInv 5 8 $ s "hh27" the hi-hat event fires on every one of the eight even beats that the bass drum does not.
euclidOff	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a	As 'euclid', but taking a third rotational parameter corresponding to the onset at which to start the rhythm.
euclidOffBool	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> Pattern Int -> Pattern Bool -> Pattern Bool	As 'euclidOff', but specialized to 'Bool'. May be more efficient than 'euclidOff'.
every	Function	Sound.Tidal.Core	Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	every n f p applies the function f to p, but only affects every n cycles. It takes three inputs: how often the function should be applied (e.g. 3 to apply it every 3 cycles), the function to be applied, and the pattern you are applying it to. For example: to reverse a pattern every three cycles (and for the other two play it normally) > d1 $ every 3 rev $ n "0 1 [~ 2] 3" # sound "arpy" Note that if the function you’re applying requires additional parameters itself (such as fast 2 to make a pattern twice as fast), then you’ll need to wrap it in parenthesis, like so: > d1 $ every 3 (fast 2) $ n "0 1 [~ 2] 3" # sound "arpy" Otherwise, the every function will think it is being passed too many parameters.
every'	Function	Sound.Tidal.Core	Pattern Int -> Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	every' n o f p is like every n f p but with an offset of o cycles. For example, every' 3 0 (fast 2) will speed up the cycle on cycles 0,3,6,… whereas every' 3 1 (fast 2) will transform the pattern on cycles 1,4,7,…. With this in mind, setting the second argument of every' to 0 gives the equivalent every function. For example, every 3 is equivalent to every' 3 0. The every functions can be used to silence a full cycle or part of a cycle by using silent or mask "~". Mask provides additional flexibility to turn on/off individual steps. > d1 $ every 3 silent $ n "2 9 11 2" # s "hh27" > d1 $ every 3 (mask "~") $ n "2 9 10 2" # s "hh27" > d1 $ every 3 (mask "0 0 0 0") $ n "2 9 11 2" # s "hh27"
expression	Param	Sound.Tidal.Params	Control parameter	
fadeIn	Function	Sound.Tidal.UI	Time -> Pattern a -> Pattern a	’Undegrades’ a pattern over the given time.
fadeInFrom	Function	Sound.Tidal.UI	Time -> Time -> Pattern a -> Pattern a	Alternate version to fadeIn where you can provide the time from which the fade in starts
fadeInTime	Param	Sound.Tidal.Params	Control parameter	As with fadeTime, but controls the fade in time of the grain envelope. Not used if the grain begins at position 0 in the sample.
fadeOut	Function	Sound.Tidal.UI	Time -> Pattern a -> Pattern a	Degrades a pattern over the given time.
fadeOutFrom	Function	Sound.Tidal.UI	Time -> Time -> Pattern a -> Pattern a	Alternate version to fadeOut where you can provide the time from which the fade starts
fadeOutTime	Param	Sound.Tidal.Params	Control parameter	
fadeTime	Param	Sound.Tidal.Params	Control parameter	Used when using begin/end or chop/striate and friends, to change the fade out time of the 'grain' envelope.
fastAppend	Function	Sound.Tidal.Core	Pattern a -> Pattern a -> Pattern a	Like 'append', but twice as fast > d1 $ fastAppend (sound "bd*2 sn") (sound "arpy jvbass*2")
fastCat	Function	Sound.Tidal.Core	[Pattern a] -> Pattern a	The same as 'cat', but speeds up the result by the number of patterns there are, so the cycles from each are squashed to fit a single cycle. > d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2"] > d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"] > d1 $ fastcat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]
fastFromList	Function	Sound.Tidal.Core	[a] -> Pattern a	Turns a list of values into a pattern, playing /all/ of them per cycle. The following are equivalent: > d1 $ n (fastFromList [0, 1, 2]) # s "superpiano" > d1 $ n "[0 1 2]" # s "superpiano"
fastGap	Function	Sound.Tidal.Core	Pattern Time -> Pattern a -> Pattern a	fastGap is similar to 'fast' but maintains its cyclic alignment, i.e., rather than playing the pattern multiple times, it instead leaves a gap in the remaining space of the cycle. For example, fastGap 2 p would squash the events in pattern p into the first half of each cycle (and the second halves would be empty). The factor should be at least 1.
fastRepeatCycles	Function	Sound.Tidal.Core	Int -> Pattern a -> Pattern a	
fastspread	Function	Sound.Tidal.UI	(a -> t -> Pattern b) -> [a] -> t -> Pattern b	fastspread works the same as `spread`, but the result is squashed into a single cycle. If you gave four values to spread, then the result would seem to speed up by a factor of four. Compare these two: > d1 $ spread chop [4,64,32,16] $ sound "ho ho:2 ho:3 hc" > d1 $ fastspread chop [4,64,32,16] $ sound "ho ho:2 ho:3 hc" There is also `slowspread`, which is an alias of spread.
fill	Function	Sound.Tidal.UI	Pattern a -> Pattern a -> Pattern a	fill 'fills in' gaps in one pattern with events from another. For example fill "bd" "cp ~ cp" would result in the equivalent of `"~ bd ~"`. This only finds gaps in a resulting pattern, in other words "[bd ~, sn]" doesn't contain any gaps (because sn covers it all), and "bd ~ ~ sn" only contains a single gap that bridges two steps.
findIndex	Function	Sound.Tidal.UI	Double -> Map.Map Double Int -> Int	
first	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	See 'Sound.Tidal.Stream.first'.
fit	Function	Sound.Tidal.UI	Pattern Int -> [a] -> Pattern Int -> Pattern a	The `fit` function takes a pattern of integer numbers, which are used to select values from the given list. What makes this a bit strange is that only a given number of values are selected each cycle. For example: > d1 $ sound (fit 3 ["bd", "sn", "arpy", "arpy:1", "casio"] "0 [~ 1] 2 1") The above fits three samples into the pattern, i.e. for the first cycle this will be "bd", "sn" and "arpy", giving the result "bd [~ sn] arpy sn" (note that we start counting at zero, so that 0 picks the first value). The following cycle the /next/ three values in the list will be picked, i.e. "arpy:1", "casio" and "bd", giving the pattern "arpy:1 [~ casio] bd casio" (note that the list wraps round here).
fit'	Function	Sound.Tidal.UI	Pattern Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a	fit' is a generalization of `fit`, where the list is instead constructed by using another integer pattern to slice up a given pattern. The first argument is the number of cycles of that latter pattern to use when slicing. It's easier to understand this with a few examples: > d1 $ sound (fit' 1 2 "0 1" "1 0" "bd sn") So what does this do? The first 1 just tells it to slice up a single cycle of "bd sn". The 2 tells it to select two values each cycle, just like the first argument to fit. The next pattern "0 1" is the "from" pattern which tells it how to slice, which in this case means "0" maps to "bd", and "1" maps to "sn". The next pattern "1 0" is the "to" pattern, which tells it how to rearrange those slices. So the final result is the pattern "sn bd". A more useful example might be something like > d1 $ fit' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" > $ chop 4 > $ (sound "breaks152" # unit "c") which uses chop to break a single sample into individual pieces, which fit' then puts into a list (using the run 4 pattern) and reassembles according to the complicated integer pattern.
fix	Function	Sound.Tidal.UI	(ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern	The fix function applies another function to matching events in a pattern of controls. fix is 'contrast' where the false-branching function is set to the identity 'id'. It is like 'contrast', but one function is given and applied to events with matching controls. For example, the following only adds the 'crush' control when the n control is set to either 1 or 4: > d1 $ slow 2 > $ fix (# crush 3) (n "[1,4]") > $ n "0 1 2 3 4 5 6" > # sound "arpy" You can be quite specific; for example, the following applies the function 'hurry' 2 to sample 1 of the drum sample set, and leaves the rest as they are: > fix (hurry 2) (s "drum" # n "1")
flatpat	Function	Sound.Tidal.UI	Pattern [a] -> Pattern a	flatpat takes a 'Pattern' of lists and pulls the list elements as separate 'Event's. For example, the following code uses flatpat in combination with listToPat to create an alternating pattern of chords: > d1 $ n (flatpat $ listToPat [[0,4,7],[(-12),(-8),(-5)]]) > # s "superpiano" # sustain 2 This code is equivalent to: > d1 $ n ("[0,4,7] [-12,-8,-5]") # s "superpiano" # sustain 2
flatten	Function	Sound.Tidal.Core	[Event a] -> [Event a]	
foldEvery	Function	Sound.Tidal.Core	[Int] -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	foldEvery ns f p applies the function f to p, and is applied for each cycle in ns. It is similar to chaining multiple every functions together. It transforms a pattern with a function, once per any of the given number of cycles. If a particular cycle is the start of more than one of the given cycle periods, then it it applied more than once. > d1 $ foldEvery [5,3] (|+ n 1) $ s "moog" # legato 1 The first moog samples are tuned to C2, C3 and C4. Note how on cycles that are multiples of 3 or 5 the pitch is an octave higher, and on multiples of 15 the pitch is two octaves higher, as the transformation is applied twice.
forId	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
frameRate	Param	Sound.Tidal.Params	Control parameter	
frames	Param	Sound.Tidal.Params	Control parameter	
freeze	Param	Sound.Tidal.Params	Control parameter	Spectral freeze
freq	Param	Sound.Tidal.Params	Control parameter	
from	Param	Sound.Tidal.Params	Control parameter	for internal sound routing
fromList	Function	Sound.Tidal.Core	[a] -> Pattern a	Turns a list of values into a pattern, playing one of them per cycle. The following are equivalent: > d1 $ n (fromList [0, 1, 2]) # s "superpiano" > d1 $ n "<0 1 2>" # s "superpiano"
fromMaybes	Function	Sound.Tidal.Core	[Maybe a] -> Pattern a	'fromMaybes; is similar to 'fromList', but allows values to be optional using the 'Maybe' type, so that 'Nothing' results in gaps in the pattern. The following are equivalent: > d1 $ n (fromMaybes [Just 0, Nothing, Just 2]) # s "superpiano" > d1 $ n "0 ~ 2" # s "superpiano"
fshift	Param	Sound.Tidal.Params	Control parameter	frequency shifter
fshiftnote	Param	Sound.Tidal.Params	Control parameter	frequency shifter
fshiftphase	Param	Sound.Tidal.Params	Control parameter	frequency shifter
gain	Param	Sound.Tidal.Params	Control parameter	Used to control the amplitude (volume) of the sound. Values less than 1 make the sound quieter and values greater than 1 make the sound louder. gain uses a power function, so the volume change around 1 is subtle, but it gets more noticeable as it increases or decreases. Typical values for gain are between 0 and 1.5. For the linear equivalent, see 'amp'. > d1 $ s "arpy" # gain 0.8 This plays the first arpy sample at a quieter level than the default. > d1 $ s "ab*16" # gain (range 0.8 1.3 $ sine) This plays a hihat sound, 16 times per cycle, with a gain moving from 0.8 to 1.3 following a sine wave.
gat	Param	Sound.Tidal.Params	Control parameter	
gate	Param	Sound.Tidal.Params	Control parameter	
getbpm	Boot	Sound.Tidal.Boot	(Tidally) => IO Time	See 'Sound.Tidal.Stream.streamGetBPM'.
getcps	Boot	Sound.Tidal.Boot	(Tidally) => IO Time	See 'Sound.Tidal.Stream.streamGetCPS'.
getnow	Boot	Sound.Tidal.Boot	(Tidally) => IO Time	See 'Sound.Tidal.Stream.streamGetnow'.
getState	Boot	Sound.Tidal.Boot	(Tidally) => String -> IO (Maybe Value)	See 'Sound.Tidal.Stream.streamGet'.
ghost	Function	Sound.Tidal.UI	Pattern ValueMap -> Pattern ValueMap	As 'ghost'', but with the copies set to appear one-eighth of a cycle afterwards. ghost = ghost' 0.125 The following creates a kick snare pattern with ghost notes applied to the snare hit: > d1 $ stack [ ghost $ sound "~ sn", sound "bd*2 [~ bd]" ]
ghost'	Function	Sound.Tidal.UI	Time -> Pattern ValueMap -> Pattern ValueMap	
ghost''	Function	Sound.Tidal.UI	Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Deprecated backwards-compatible alias for 'ghostWith'.
ghostWith	Function	Sound.Tidal.UI	Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Like 'ghost'', but a user-supplied function describes how to alter the pattern. In this example, ghost notes are applied to the snare hit, but these notes will be louder, not quieter, and the sample will have its beginning slightly cut: > d1 $ slow 2 > $ ghostWith (1/16) ((|*| gain 1.1) . (|> begin 0.05)) > $ sound "sn"
grain	Function	Sound.Tidal.UI	Pattern Double -> Pattern Double -> ControlPattern	Given a start point and a duration (both specified in cycles), this generates a control pattern that makes a sound begin at the start point and last the duration. The following are equivalent: > d1 $ slow 2 $ s "bev" # grain 0.2 0.1 # legato 1 > d1 $ slow 2 $ s "bev" # begin 0.2 # end 0.3 # legato 1 grain is defined as: > grain s d = 'Sound.Tidal.Params.begin' s # 'Sound.Tidal.Params.end' (s+d)
grain'	Param	Sound.Tidal.Params	Control parameter	grain' is a shortcut to join a begin and end These are equivalent: > d1 $ slow 2 $ s "bev" # grain' "0.2:0.3" # legato 1 > d1 $ slow 2 $ s "bev" # begin 0.2 # end 0.3 # legato 1
harmonic	Param	Sound.Tidal.Params	Control parameter	
hatgrain	Param	Sound.Tidal.Params	Control parameter	
hbrick	Param	Sound.Tidal.Params	Control parameter	High pass sort of spectral filter
hcutoff	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Applies the cutoff frequency of the high-pass filter. Also has alias hpf
hg	Param	Sound.Tidal.Params	Control parameter	
histpan	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Int -> ControlPattern -> IO ()	
hold	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers to specify the hold time (in seconds) of an envelope applied to each sample. Only takes effect if `attack` and `release` are also specified.
hours	Param	Sound.Tidal.Params	Control parameter	
hpf	Param	Sound.Tidal.Params	Control parameter	
hpq	Param	Sound.Tidal.Params	Control parameter	
hresonance	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Applies the resonance of the high-pass filter. Has alias hpq
hush	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	See 'Sound.Tidal.Stream.streamHush'.
ifp	Function	Sound.Tidal.UI	(Int -> Bool) -> (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Decide whether to apply one or another function depending on the result of a test function, which is passed the current cycle as a number. d1 $ ifp ((== 0) . flip mod 2) (striate 4) (# coarse "24 48") $ sound "hh hc" This will apply 'striate' 4 for every /even/ cycle and apply # coarse "24 48" for every /odd/. Detail: As you can see the test function is arbitrary and does not rely on anything Tidal specific. In fact it uses only plain Haskell functionality, that is: it calculates the modulo of 2 of the current cycle which is either 0 (for even cycles) or 1. It then compares this value against 0 and returns the result, which is either True or False. This is what the ifp signature's first part signifies: (Int -> Bool), a function that takes a whole number and returns either True or False.
imag	Param	Sound.Tidal.Params	Control parameter	
in0	Function	Sound.Tidal.Core	Pattern Double	Default controller inputs (for MIDI)
in1	Function	Sound.Tidal.Core	Pattern Double	
in10	Function	Sound.Tidal.Core	Pattern Double	
in100	Function	Sound.Tidal.Core	Pattern Double	
in101	Function	Sound.Tidal.Core	Pattern Double	
in102	Function	Sound.Tidal.Core	Pattern Double	
in103	Function	Sound.Tidal.Core	Pattern Double	
in104	Function	Sound.Tidal.Core	Pattern Double	
in105	Function	Sound.Tidal.Core	Pattern Double	
in106	Function	Sound.Tidal.Core	Pattern Double	
in107	Function	Sound.Tidal.Core	Pattern Double	
in108	Function	Sound.Tidal.Core	Pattern Double	
in109	Function	Sound.Tidal.Core	Pattern Double	
in11	Function	Sound.Tidal.Core	Pattern Double	
in110	Function	Sound.Tidal.Core	Pattern Double	
in111	Function	Sound.Tidal.Core	Pattern Double	
in112	Function	Sound.Tidal.Core	Pattern Double	
in113	Function	Sound.Tidal.Core	Pattern Double	
in114	Function	Sound.Tidal.Core	Pattern Double	
in115	Function	Sound.Tidal.Core	Pattern Double	
in116	Function	Sound.Tidal.Core	Pattern Double	
in117	Function	Sound.Tidal.Core	Pattern Double	
in118	Function	Sound.Tidal.Core	Pattern Double	
in119	Function	Sound.Tidal.Core	Pattern Double	
in12	Function	Sound.Tidal.Core	Pattern Double	
in120	Function	Sound.Tidal.Core	Pattern Double	
in121	Function	Sound.Tidal.Core	Pattern Double	
in122	Function	Sound.Tidal.Core	Pattern Double	
in123	Function	Sound.Tidal.Core	Pattern Double	
in124	Function	Sound.Tidal.Core	Pattern Double	
in125	Function	Sound.Tidal.Core	Pattern Double	
in126	Function	Sound.Tidal.Core	Pattern Double	
in127	Function	Sound.Tidal.Core	Pattern Double	
in13	Function	Sound.Tidal.Core	Pattern Double	
in14	Function	Sound.Tidal.Core	Pattern Double	
in15	Function	Sound.Tidal.Core	Pattern Double	
in16	Function	Sound.Tidal.Core	Pattern Double	
in17	Function	Sound.Tidal.Core	Pattern Double	
in18	Function	Sound.Tidal.Core	Pattern Double	
in19	Function	Sound.Tidal.Core	Pattern Double	
in2	Function	Sound.Tidal.Core	Pattern Double	
in20	Function	Sound.Tidal.Core	Pattern Double	
in21	Function	Sound.Tidal.Core	Pattern Double	
in22	Function	Sound.Tidal.Core	Pattern Double	
in23	Function	Sound.Tidal.Core	Pattern Double	
in24	Function	Sound.Tidal.Core	Pattern Double	
in25	Function	Sound.Tidal.Core	Pattern Double	
in26	Function	Sound.Tidal.Core	Pattern Double	
in27	Function	Sound.Tidal.Core	Pattern Double	
in28	Function	Sound.Tidal.Core	Pattern Double	
in29	Function	Sound.Tidal.Core	Pattern Double	
in3	Function	Sound.Tidal.Core	Pattern Double	
in30	Function	Sound.Tidal.Core	Pattern Double	
in31	Function	Sound.Tidal.Core	Pattern Double	
in32	Function	Sound.Tidal.Core	Pattern Double	
in33	Function	Sound.Tidal.Core	Pattern Double	
in34	Function	Sound.Tidal.Core	Pattern Double	
in35	Function	Sound.Tidal.Core	Pattern Double	
in36	Function	Sound.Tidal.Core	Pattern Double	
in37	Function	Sound.Tidal.Core	Pattern Double	
in38	Function	Sound.Tidal.Core	Pattern Double	
in39	Function	Sound.Tidal.Core	Pattern Double	
in4	Function	Sound.Tidal.Core	Pattern Double	
in40	Function	Sound.Tidal.Core	Pattern Double	
in41	Function	Sound.Tidal.Core	Pattern Double	
in42	Function	Sound.Tidal.Core	Pattern Double	
in43	Function	Sound.Tidal.Core	Pattern Double	
in44	Function	Sound.Tidal.Core	Pattern Double	
in45	Function	Sound.Tidal.Core	Pattern Double	
in46	Function	Sound.Tidal.Core	Pattern Double	
in47	Function	Sound.Tidal.Core	Pattern Double	
in48	Function	Sound.Tidal.Core	Pattern Double	
in49	Function	Sound.Tidal.Core	Pattern Double	
in5	Function	Sound.Tidal.Core	Pattern Double	
in50	Function	Sound.Tidal.Core	Pattern Double	
in51	Function	Sound.Tidal.Core	Pattern Double	
in52	Function	Sound.Tidal.Core	Pattern Double	
in53	Function	Sound.Tidal.Core	Pattern Double	
in54	Function	Sound.Tidal.Core	Pattern Double	
in55	Function	Sound.Tidal.Core	Pattern Double	
in56	Function	Sound.Tidal.Core	Pattern Double	
in57	Function	Sound.Tidal.Core	Pattern Double	
in58	Function	Sound.Tidal.Core	Pattern Double	
in59	Function	Sound.Tidal.Core	Pattern Double	
in6	Function	Sound.Tidal.Core	Pattern Double	
in60	Function	Sound.Tidal.Core	Pattern Double	
in61	Function	Sound.Tidal.Core	Pattern Double	
in62	Function	Sound.Tidal.Core	Pattern Double	
in63	Function	Sound.Tidal.Core	Pattern Double	
in64	Function	Sound.Tidal.Core	Pattern Double	
in65	Function	Sound.Tidal.Core	Pattern Double	
in66	Function	Sound.Tidal.Core	Pattern Double	
in67	Function	Sound.Tidal.Core	Pattern Double	
in68	Function	Sound.Tidal.Core	Pattern Double	
in69	Function	Sound.Tidal.Core	Pattern Double	
in7	Function	Sound.Tidal.Core	Pattern Double	
in70	Function	Sound.Tidal.Core	Pattern Double	
in71	Function	Sound.Tidal.Core	Pattern Double	
in72	Function	Sound.Tidal.Core	Pattern Double	
in73	Function	Sound.Tidal.Core	Pattern Double	
in74	Function	Sound.Tidal.Core	Pattern Double	
in75	Function	Sound.Tidal.Core	Pattern Double	
in76	Function	Sound.Tidal.Core	Pattern Double	
in77	Function	Sound.Tidal.Core	Pattern Double	
in78	Function	Sound.Tidal.Core	Pattern Double	
in79	Function	Sound.Tidal.Core	Pattern Double	
in8	Function	Sound.Tidal.Core	Pattern Double	
in80	Function	Sound.Tidal.Core	Pattern Double	
in81	Function	Sound.Tidal.Core	Pattern Double	
in82	Function	Sound.Tidal.Core	Pattern Double	
in83	Function	Sound.Tidal.Core	Pattern Double	
in84	Function	Sound.Tidal.Core	Pattern Double	
in85	Function	Sound.Tidal.Core	Pattern Double	
in86	Function	Sound.Tidal.Core	Pattern Double	
in87	Function	Sound.Tidal.Core	Pattern Double	
in88	Function	Sound.Tidal.Core	Pattern Double	
in89	Function	Sound.Tidal.Core	Pattern Double	
in9	Function	Sound.Tidal.Core	Pattern Double	
in90	Function	Sound.Tidal.Core	Pattern Double	
in91	Function	Sound.Tidal.Core	Pattern Double	
in92	Function	Sound.Tidal.Core	Pattern Double	
in93	Function	Sound.Tidal.Core	Pattern Double	
in94	Function	Sound.Tidal.Core	Pattern Double	
in95	Function	Sound.Tidal.Core	Pattern Double	
in96	Function	Sound.Tidal.Core	Pattern Double	
in97	Function	Sound.Tidal.Core	Pattern Double	
in98	Function	Sound.Tidal.Core	Pattern Double	
in99	Function	Sound.Tidal.Core	Pattern Double	
index	Function	Sound.Tidal.UI	(Real b) => b -> Pattern b -> Pattern c -> Pattern c	
inhabit	Function	Sound.Tidal.UI	[(String, Pattern a)] -> Pattern String -> Pattern a	A simpler version of 'ur' that just provides name-value bindings that are reflected in the provided pattern. inhabit allows you to link patterns to some String, or in other words, to give patterns a name and then call them from within another pattern of Strings. For example, we can make our own bassdrum, hi-hat and snaredrum kit: > do > let drum = inhabit [ ("bd", s "sine" |- accelerate 1.5) > , ("hh", s "alphabet:7" # begin 0.7 # hpf 7000) > , ("sd", s "invaders:3" # speed 12) > d1 $ drum "[bd*8?, [~hh]*4, sd(6,16)]" inhabit can be very useful when using MIDI controlled drum machines, since you can give understandable drum names to patterns of notes.
inside	Function	Sound.Tidal.UI	Pattern Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a	inside carries out an operation /inside/ a cycle. For example, while rev "0 1 2 3 4 5 6 7" is the same as "7 6 5 4 3 2 1 0", inside 2 rev "0 1 2 3 4 5 6 7" gives "3 2 1 0 7 6 5 4". What this function is really doing is ‘slowing down’ the pattern by a given factor, applying the given function to it, and then ‘speeding it up’ by the same factor. In other words, this: > inside 2 rev "0 1 2 3 4 5 6 7" Is doing this: > fast 2 $ rev $ slow 2 "0 1 2 3 4 5 6 7" so rather than whole cycles, each half of a cycle is reversed.
interpolate	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	
interpolateIn	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
intSeedToRand	Function	Sound.Tidal.UI	(Fractional a) => Int -> a	
inv	Function	Sound.Tidal.UI	(Functor f) => f Bool -> f Bool	Inverts all the values in a boolean pattern
irand	Function	Sound.Tidal.UI	(Num a) => Pattern Int -> Pattern a	Just like `rand` but for whole numbers, irand n generates a pattern of (pseudo-) random whole numbers between 0 to n-1 inclusive. Notably used to pick a random samples from a folder: d1 $ segment 4 $ n (irand 5) # sound "drum"
isaw	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	isaw like saw, but a descending (inverse) sawtooth.
isaw2	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	isaw2 like saw2, but a descending (inverse) sawtooth.
iter	Function	Sound.Tidal.UI	Pattern Int -> Pattern c -> Pattern c	Divides a pattern into a given number of subdivisions, plays the subdivisions in order, but increments the starting subdivision each cycle. The pattern wraps to the first subdivision after the last subdivision is played. Example: d1 $ iter 4 $ sound "bd hh sn cp" This will produce the following over four cycles: bd hh sn cp hh sn cp bd sn cp bd hh cp bd hh sn There is also `iter'`, which shifts the pattern in the opposite direction.
iter'	Function	Sound.Tidal.UI	Pattern Int -> Pattern c -> Pattern c	iter' is the same as iter, but decrements the starting subdivision instead of incrementing it. For example, d1 $ iter' 4 $ sound "bd hh sn cp" produces bd hh sn cp cp bd hh sn sn cp bd hh hh sn cp bd
jump	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	
jumpIn	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Int -> ControlPattern -> IO ()	
jumpIn'	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Int -> ControlPattern -> IO ()	
jumpMod	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Int -> ControlPattern -> IO ()	
jumpMod'	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Int -> Int -> ControlPattern -> IO ()	
jux'	Function	Sound.Tidal.UI	[t -> Pattern ValueMap] -> t -> Pattern ValueMap	In addition to `jux`, `jux'` allows using a list of pattern transformations. Resulting patterns from each transformation will be spread via pan from left to right. For example, the following will put iter 4 of the pattern to the far left and `palindrome` to the far right. In the center, the original pattern will play and the chopped and the reversed version will appear mid left and mid right respectively. > d1 $ jux' [iter 4, chop 16, id, rev, palindrome] $ sound "bd sn" One could also write: d1 $ stack [ iter 4 $ sound "bd sn" # pan "0" , chop 16 $ sound "bd sn" # pan "0.25" , sound "bd sn" # pan "0.5" , rev $ sound "bd sn" # pan "0.75" , palindrome $ sound "bd sn" # pan "1"
juxcut'	Function	Sound.Tidal.UI	[t -> Pattern ValueMap] -> t -> Pattern ValueMap	
kcutoff	Param	Sound.Tidal.Params	Control parameter	
krush	Param	Sound.Tidal.Params	Control parameter	shape/bass enhancer
lag	Param	Sound.Tidal.Params	Control parameter	
lagogo	Param	Sound.Tidal.Params	Control parameter	
layer	Function	Sound.Tidal.UI	[a -> Pattern b] -> a -> Pattern b	layer takes a list of 'Pattern'-returning functions and a seed element, stacking the result of applying the seed element to each function in the list. It allows you to layer up multiple functions on one pattern. For example, the following will play two versions of the pattern at the same time, one reversed and one at twice the speed: > d1 $ layer [rev, fast 2] $ sound "arpy [~ arpy:4]" The original version of the pattern can be included by using the id function: > d1 $ layer [id, rev, fast 2] $ sound "arpy [~ arpy:4]"
lbd	Param	Sound.Tidal.Params	Control parameter	
lbrick	Param	Sound.Tidal.Params	Control parameter	Low pass sort of spectral filter
lch	Param	Sound.Tidal.Params	Control parameter	
lcl	Param	Sound.Tidal.Params	Control parameter	
lclap	Param	Sound.Tidal.Params	Control parameter	
lclaves	Param	Sound.Tidal.Params	Control parameter	
lclhat	Param	Sound.Tidal.Params	Control parameter	
lcp	Param	Sound.Tidal.Params	Control parameter	
lcr	Param	Sound.Tidal.Params	Control parameter	
lcrash	Param	Sound.Tidal.Params	Control parameter	
legato	Param	Sound.Tidal.Params	Control parameter	controls the amount of overlap between two adjacent sounds
leslie	Param	Sound.Tidal.Params	Control parameter	
lfo	Param	Sound.Tidal.Params	Control parameter	
lfoc	Param	Sound.Tidal.Params	Control parameter	
lfocutoffint	Param	Sound.Tidal.Params	Control parameter	
lfodelay	Param	Sound.Tidal.Params	Control parameter	
lfoi	Param	Sound.Tidal.Params	Control parameter	
lfoint	Param	Sound.Tidal.Params	Control parameter	
lfop	Param	Sound.Tidal.Params	Control parameter	
lfopitchint	Param	Sound.Tidal.Params	Control parameter	
lfoshape	Param	Sound.Tidal.Params	Control parameter	
lfosync	Param	Sound.Tidal.Params	Control parameter	
lhitom	Param	Sound.Tidal.Params	Control parameter	
lht	Param	Sound.Tidal.Params	Control parameter	
lindenmayer	Function	Sound.Tidal.UI	Int -> String -> String -> String	Returns the nth iteration of a [Lindenmayer System](https://en.wikipedia.org/wiki/L-system) with given start sequence. It takes an integer b, a Lindenmayer system rule set, and an initiating string as input in order to generate an L-system tree string of b iterations. It can be used in conjunction with a step function to convert the generated string into a playable pattern. For example, > d1 $ slow 16 > $ sound > $ step' ["feel:0", "sn:1", "bd:0"] > ( take 512 > $ lindenmayer 5 "0:1~~~,1:0~~~2~~~~~0~~~2~,2:2~1~,~:~~1~" "0" generates an L-system with initiating string "0" and maps it onto a list of samples. Complex L-system trees with many rules and iterations can sometimes result in unwieldy strings. Using take n to only use the first n elements of the string, along with a 'slow' function, can make the generated values more manageable.
lindenmayerI	Function	Sound.Tidal.UI	(Num b) => Int -> String -> String -> [b]	lindenmayerI converts the resulting string into a a list of integers with fromIntegral applied (so they can be used seamlessly where floats or rationals are required)
linger	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	linger is similar to `trunc`, in that it truncates a pattern so that only the first fraction of the pattern is played, but the truncated part of the pattern loops to fill the remainder of the cycle. > d1 $ linger 0.25 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2" For example this repeats the first quarter, so you only hear a single repeating note: > d1 $ linger 0.25 $ n "0 2 [3 4] 2" # sound "arpy" or slightly more interesting, applied only every fourth cycle: > d1 $ every 4 (linger 0.25) $ n "0 2 [3 4] 2" # sound "arpy" or to a chopped-up sample: > d1 $ every 2 (linger 0.25) $ loopAt 2 $ chop 8 $ sound "breaks125" You can also pattern the first parameter, for example to cycle through three values, one per cycle: > d1 $ linger "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc" > d1 $ linger "<0.25 0.5 1>" $ loopAt 2 $ chop 8 $ sound "breaks125" If you give it a negative number, it will linger on the last part of the pattern, instead of the start of it. E.g. to linger on the last quarter: > d1 $ linger (-0.25) $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"
list	Boot	Sound.Tidal.Boot	(Tidally) => IO () | Sound.Tidal.UI	See 'Sound.Tidal.Stream.streamList'.
listToPat	Function	Sound.Tidal.Core	[a] -> Pattern a	A synonym for 'fastFromList'
lkick	Param	Sound.Tidal.Params	Control parameter	
llotom	Param	Sound.Tidal.Params	Control parameter	
llt	Param	Sound.Tidal.Params	Control parameter	
lock	Param	Sound.Tidal.Params	Control parameter	A pattern of numbers. Specifies whether delaytime is calculated relative to cps. When set to 1, delaytime is a direct multiple of a cycle.
loh	Param	Sound.Tidal.Params	Control parameter	
loop	Param	Sound.Tidal.Params	Control parameter	loops the sample (from `begin` to `end`) the specified number of times.
loopFirst	Function	Sound.Tidal.UI	Pattern a -> Pattern a	Takes a pattern and loops only the first cycle of the pattern. For example, the following code will only play the bass drum sample: > d1 $ loopFirst $ s "<<bd*4 ht*8> cp*4>" This function combines with 'sometimes' to insert events from the first cycle randomly into subsequent cycles of the pattern: > d1 $ sometimes loopFirst $ s "<<bd*4 ht*8> cp*4>"
lophat	Param	Sound.Tidal.Params	Control parameter	
lpf	Param	Sound.Tidal.Params	Control parameter	
lpq	Param	Sound.Tidal.Params	Control parameter	
lrate	Param	Sound.Tidal.Params	Control parameter	
lsize	Param	Sound.Tidal.Params	Control parameter	
lsn	Param	Sound.Tidal.Params	Control parameter	
lsnare	Param	Sound.Tidal.Params	Control parameter	
markOut	Function	Sound.Tidal.UI	Time -> [Time] -> [Arc]	
markovPat	Function	Sound.Tidal.UI	Pattern Int -> Pattern Int -> [[Double]] -> Pattern Int	markovPat n xi tp generates a one-cycle pattern of n steps in a Markov chain starting from state xi with transition matrix tp. Each row of the transition matrix is automatically normalized. For example: >>> markovPat 8 1 [[3,5,2], [4,4,2], [0,1,0]]
mask	Function	Sound.Tidal.UI	Pattern Bool -> Pattern a -> Pattern a	mask takes a boolean pattern and ‘masks’ another pattern with it. That is, events are only carried over if they match within a ‘true’ event in the binary pattern, i.e., it removes events from the second pattern that don't start during an event from the first. For example, consider this kind of messy rhythm without any rests. > d1 $ sound (slowcat ["sn*8", "[cp*4 bd*4, hc*5]"]) # n (run 8) If we apply a mask to it d1 $ s ( mask ("1 1 1 ~ 1 1 ~ 1" :: Pattern Bool) ( slowcat ["sn*8", "[cp*4 bd*4, bass*5]"] ) # n (run 8) Due to the use of `slowcat` here, the same mask is first applied to "sn*8" and in the next cycle to "[cp*4 bd*4, hc*5]". You could achieve the same effect by adding rests within the `slowcat` patterns, but mask allows you to do this more easily. It kind of keeps the rhythmic structure and you can change the used samples independently, e.g., d1 $ s ( mask ("1 ~ 1 ~ 1 1 ~ 1") ( slowcat ["can*8", "[cp*4 sn*4, jvbass*16]"] ) # n (run 8)
matched	Function	Sound.Tidal.UI	ControlPattern	
metatune	Param	Sound.Tidal.Params	Control parameter	A pattern of numbers. Specifies whether the pitch of played samples should be tuned relative to their pitch metadata, if it exists. When set to 1, pitch metadata is applied. When set to 0, pitch metadata is ignored.
midibend	Param	Sound.Tidal.Params	Control parameter	
midichan	Param	Sound.Tidal.Params	Control parameter	
midicmd	Param	Sound.Tidal.Params	Control parameter	
miditouch	Param	Sound.Tidal.Params	Control parameter	
minutes	Param	Sound.Tidal.Params	Control parameter	
mkOscMap	Boot	Sound.Tidal.Boot	OscMap	A reasonable OscMap
mkTidal	Boot	Sound.Tidal.Boot	IO Stream	Creates a Tidal instance using default config. Use 'mkTidalWith' to customize.
mkTidalWith	Boot	Sound.Tidal.Boot	OscMap -> Config -> IO Stream	See 'Sound.Tidal.Stream.startStream'.
modwheel	Param	Sound.Tidal.Params	Control parameter	
mono	Function	Sound.Tidal.Core	Pattern a -> Pattern a	Serialises a pattern so there's only one event playing at any one time, making it /monophonic/. Events which start/end earlier are given priority.
mortal	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> Time -> ControlPattern -> IO ()	
mtranspose	Param	Sound.Tidal.Params	Control parameter	
mute	Boot	Sound.Tidal.Boot	(Tidally) => ID -> IO ()	See 'Sound.Tidal.Stream.streamMute'.
n	Param	Sound.Tidal.Params	Control parameter	The note or sample number to choose for a synth or sampleset
necklace	Function	Sound.Tidal.UI	Rational -> [Int] -> Pattern Bool	For specifying a boolean pattern according to a list of offsets (aka inter-onset intervals). For example necklace 12 [4,2] is the same as "t f f f t f t f f f t f". That is, 12 steps per cycle, with true values alternating between every 4 and every 2 steps.
never	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	Never apply a transformation, returning the pattern unmodified.
normal	Function	Sound.Tidal.UI	(Floating a, Ord a) => Pattern a	Generates values in [0,1] that follows a normal (bell-curve) distribution. One possible application is to "humanize" drums with a slight random delay: d1 $ s "bd sn bd sn" # nudge (segment 4 (0.01 * normal)) Implemented with the Box-Muller transform. * the max ensures we don't calculate log 0 * the rot in u2 ensures we don't just get the same value as u1 * clamp the Box-Muller generated values in a [-3,3] range
note	Param	Sound.Tidal.Params	Control parameter	The note or pitch to play a sound or synth with
noteLookup	Function	Sound.Tidal.UI	String -> Maybe Int	
nrpn	Param	Sound.Tidal.Params	Control parameter	
nrpnn	Param	Sound.Tidal.Params	Control parameter	
nrpnv	Param	Sound.Tidal.Params	Control parameter	
nT	Function	Sound.Tidal.UI	Time	
nudge	Param	Sound.Tidal.Params	Control parameter	Nudges events into the future by the specified number of seconds. Negative numbers work up to a point as well (due to internal latency)
nudgeAll	Boot	Sound.Tidal.Boot	(Tidally) => Double -> IO ()	See 'Sound.Tidal.Stream.nudgeAll'.
number	Param	Sound.Tidal.Params	Control parameter	
octave	Param	Sound.Tidal.Params	Control parameter	
octaveR	Param	Sound.Tidal.Params	Control parameter	
octer	Param	Sound.Tidal.Params	Control parameter	octaver effect
octersub	Param	Sound.Tidal.Params	Control parameter	octaver effect
octersubsub	Param	Sound.Tidal.Params	Control parameter	octaver effect
off	Function	Sound.Tidal.UI	Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	off is similar to 'superimpose', in that it applies a function to a pattern and layers up the results on top of the original pattern. The difference is that off takes an extra pattern being a time (in cycles) to shift the transformed version of the pattern by. The following plays a pattern on top of itself, but offset by an eighth of a cycle, with a distorting bitcrush effect applied: > d1 $ off 0.125 (# crush 2) $ sound "bd [~ sn:2] mt lt*2" The following makes arpeggios by adding offset patterns that are shifted up the scale: > d1 $ slow 2 > $ n (off 0.25 (+12) > $ off 0.125 (+7) > $ slow 2 "c(3,8) a(3,8,2) f(3,8) e(3,8,4)") > # sound "superpiano"
offadd	Function	Sound.Tidal.UI	(Num a) => Pattern Time -> Pattern a -> Pattern a -> Pattern a	
offset	Param	Sound.Tidal.Params	Control parameter	
often	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	often is an alias for 'sometimesBy' 0.75.
often'	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	often' is an alias for 'sometimesBy'' 0.75.
ohdecay	Param	Sound.Tidal.Params	Control parameter	
once	Boot	Sound.Tidal.Boot	(Tidally) => ControlPattern -> IO ()	See 'Sound.Tidal.Stream.streamOnce'.
only	Boot	Sound.Tidal.Boot	(Tidally) => IO () -> IO ()	'hush' then execute the given action.
ophatdecay	Param	Sound.Tidal.Params	Control parameter	
orbit	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers. An "orbit" is a global parameter context for patterns. Patterns with the same orbit will share hardware output bus offset and global effects, e.g. reverb and delay. The maximum number of orbits is specified in the superdirt startup, numbers higher than maximum will wrap around.
outside	Function	Sound.Tidal.UI	Pattern Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a	outside is the inverse of the 'inside' function. outside applies its function /outside/ the cycle. Say you have a pattern that takes 4 cycles to repeat and apply the rev function: > d1 $ rev $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"] The above generates: > d1 $ rev $ cat [s "sn bd bd",s "bd sn sn", s "sd lt lt", s "bd sd sd"] However if you apply outside: > d1 $ outside 4 (rev) $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"] The result is: > d1 $ rev $ cat [s "bd sd sd", s "sd lt lt", s "sn sn bd", s "bd bd sn"] Notice that the whole idea has been reversed. What this function is really doing is ‘speeding up’ the pattern by a given factor, applying the given function to it, and then ‘slowing it down’ by the same factor. In other words, this: > d1 $ slow 4 $ rev $ fast 4 > $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"] This compresses the idea into a single cycle before rev operates and then slows it back to the original speed.
overgain	Param	Sound.Tidal.Params	Control parameter	
overlay	Function	Sound.Tidal.Core	Pattern a -> Pattern a -> Pattern a	overlay combines two 'Pattern's into a new pattern, so that their events are combined over time. For example, the following two lines are equivalent: > d1 $ sound (overlay "bd sn:2" "cp*3") > d1 $ sound "[bd sn:2, cp*3]" overlay is equal to '<>', > (<>) :: Semigroup a => a -> a -> a which can thus be used as an infix operator equivalent of 'overlay': > d1 $ sound ("bd sn:2" <> "cp*3")
overshape	Param	Sound.Tidal.Params	Control parameter	
p	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	See 'Sound.Tidal.Stream.streamReplace'.
p_	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	Silences a specific stream, regardless of ControlPattern input. Useful for rapid muting of streams
palindrome	Function	Sound.Tidal.UI	Pattern a -> Pattern a	palindrome p applies rev to p every other cycle, so that the pattern alternates between forwards and backwards. For example, these are equivalent: d1 $ palindrome $ sound "arpy:0 arpy:1 arpy:2 arpy:3" d1 $ slow 2 $ sound "arpy:0 arpy:1 arpy:2 arpy:3 arpy:3 arpy:2 arpy:1 arpy:0" d1 $ every 2 rev $ sound "arpy:0 arpy:1 arpy:2 arpy:3"
pan	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)
panic	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	
panorient	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers between -1.0 and 1.0, which controls the relative position of the centre pan in a pair of adjacent speakers (multichannel only)
panspan	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers between -inf and inf, which controls how much multichannel output is fanned out (negative is backwards ordering)
pansplay	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers between 0.0 and 1.0, which controls the multichannel spread range (multichannel only)
panwidth	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers between 0.0 and inf, which controls how much each channel is distributed over neighbours (multichannel only)
parseLMRule	Function	Sound.Tidal.UI	String -> [(String, String)]	Lindenmayer patterns, these go well with the step sequencer general rule parser (strings map to strings)
parseLMRule'	Function	Sound.Tidal.UI	String -> [(Char, String)]	specific parser for step sequencer (chars map to string) ruleset in form "a:b,b:ab"
partials	Param	Sound.Tidal.Params	Control parameter	
pequal	Function	Sound.Tidal.UI	Ord a => Time -> Pattern a -> Pattern a -> Bool	pequal cycles p1 p2: quickly test if p1 and p2 are the same.
perlin	Function	Sound.Tidal.UI	(Fractional a) => Pattern a	As 'perlin' with a suitable choice of input pattern ('sig' 'fromRational'). The perlin function produces a new random value to move to every cycle. If you want a new random value to be generated more or less frequently, you can use fast or slow, respectively: > d1 $ sound "bd*32" # speed (fast 4 $ perlin + 0.5) > d1 $ sound "bd*32" # speed (slow 4 $ perlin + 0.5)
perlin2	Function	Sound.Tidal.UI	Pattern Double -> Pattern Double	As 'perlin2' with a suitable choice of input pattern ('sig' 'fromRational').
perlin2With	Function	Sound.Tidal.UI	Pattern Double -> Pattern Double -> Pattern Double	perlin2With is Perlin noise with a 2-dimensional input. This can be useful for more control over how the randomness repeats (or doesn't). d1 $ s "[supersaw:-12*32]" # lpf (rangex 60 5000 $ perlin2With (cosine*2) (sine*2)) # lpq 0.3 The above will generate a smooth random cutoff pattern that repeats every cycle without any reversals or discontinuities (because the 2D path is a circle). See also: `perlin2`, which only needs one input because it uses the cycle count as the second input.
perlinWith	Function	Sound.Tidal.UI	(Fractional a) => Pattern Double -> Pattern a	1D Perlin (smooth) noise, works like 'rand' but smoothly moves between random values each cycle. perlinWith takes a pattern as the random number generator's "input" instead of automatically using the cycle count. > d1 $ s "arpy*32" # cutoff (perlinWith (saw * 4) * 2000) will generate a smooth random pattern for the cutoff frequency which will repeat every cycle (because the saw does). The `perlin` function uses the cycle count as input and can be used much like rand.
permstep	Function	Sound.Tidal.UI	(RealFrac b) => Int -> [a] -> Pattern b -> Pattern a	
phasdp	Param	Sound.Tidal.Params	Control parameter	
phasdpbus	Param	Sound.Tidal.Params	Control parameter	
phasdprecv	Param	Sound.Tidal.Params	Control parameter	
phaserdepth	Param	Sound.Tidal.Params	Control parameter	Phaser Audio DSP effect | params are 'phaserrate' and 'phaserdepth'
phaserrate	Param	Sound.Tidal.Params	Control parameter	Phaser Audio DSP effect | params are 'phaserrate' and 'phaserdepth'
phasr	Param	Sound.Tidal.Params	Control parameter	
phasrbus	Param	Sound.Tidal.Params	Control parameter	
phasrrecv	Param	Sound.Tidal.Params	Control parameter	
pick	Function	Sound.Tidal.UI	String -> Int -> String	Given a sample's directory name and number, this generates a string suitable to pass to 'Data.String.fromString' to create a 'Pattern String'. 'samples' is a 'Pattern'-compatible interface to this function. pick name n = name ++ ":" ++ show n
pickF	Function	Sound.Tidal.UI	Pattern Int -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a	Chooses from a list of functions, using a pattern of integers.
pit1	Param	Sound.Tidal.Params	Control parameter	
pit1bus	Param	Sound.Tidal.Params	Control parameter	
pit1recv	Param	Sound.Tidal.Params	Control parameter	
pit2	Param	Sound.Tidal.Params	Control parameter	
pit2bus	Param	Sound.Tidal.Params	Control parameter	
pit2recv	Param	Sound.Tidal.Params	Control parameter	
pit3	Param	Sound.Tidal.Params	Control parameter	
pit3bus	Param	Sound.Tidal.Params	Control parameter	
pit3recv	Param	Sound.Tidal.Params	Control parameter	
pitch1	Param	Sound.Tidal.Params	Control parameter	
pitch2	Param	Sound.Tidal.Params	Control parameter	
pitch3	Param	Sound.Tidal.Params	Control parameter	
ply	Function	Sound.Tidal.UI	Pattern Rational -> Pattern a -> Pattern a	ply n repeats each event n times within its arc. For example, the following are equivalent: d1 $ ply 3 $ s "bd ~ sn cp" d1 $ s "[bd bd bd] ~ [sn sn sn] [cp cp cp]" The first parameter may be given as a pattern, so that the following are equivalent: d1 $ ply "2 3" $ s "bd ~ sn cp" d1 $ s "[bd bd] ~ [sn sn sn] [cp cp cp]" Here is an example of it being used conditionally: d1 $ every 3 (ply 4) $ s "bd ~ sn cp"
plyWith	Function	Sound.Tidal.UI	(Ord t, Num t) => Pattern t -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	As 'ply', but applies a function each time. The applications are compounded.
polyTouch	Param	Sound.Tidal.Params	Control parameter	
por	Param	Sound.Tidal.Params	Control parameter	
porbus	Param	Sound.Tidal.Params	Control parameter	
porrecv	Param	Sound.Tidal.Params	Control parameter	
portamento	Param	Sound.Tidal.Params	Control parameter	
prep	Function	Sound.Tidal.UI	(Time, Time) -> Pattern String -> Pattern b -> Pattern b	prep is an alias for preplace.
preplace	Function	Sound.Tidal.UI	(Time, Time) -> Pattern String -> Pattern b -> Pattern b	
preplace1	Function	Sound.Tidal.UI	Pattern String -> Pattern b -> Pattern b	
preplaceWith	Function	Sound.Tidal.UI	(a -> b -> c) -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c	
preplaceWith1	Function	Sound.Tidal.UI	(a -> b -> c) -> Pattern a -> Pattern b -> Pattern c	
press	Function	Sound.Tidal.UI	Pattern a -> Pattern a	Syncopates a rhythm, shifting (delaying) each event halfway into its arc (timespan). In mini-notation terms, it basically turns every instance of a into [~ a], e.g., "a b [c d] e" becomes the equivalent of "[~ a] [~ b] [[~ c] [~ d]] [~ e]". Every beat then becomes an offbeat, and so the overall effect is to syncopate a pattern. In the following example, you can hear that the piano chords play between the snare and the bass drum. In 4/4 time, they are playing in the 2 and a half, and 4 and a half beats: > do > resetCycles > d1 $ stack [ > press $ n "~ c'maj ~ c'maj" # s "superpiano" # gain 0.9 # pan 0.6, > s "[bd,clap sd bd sd]" # pan 0.4 > ] # cps (90/60/4) In the next example, the C major chord plays before the G major. As the slot that occupies the C chord is that of one eighth note, it is displaced by press only a sixteenth note: > do > resetCycles > d1 $ stack [ > press $ n "~ [c'maj ~] ~ ~" # s "superpiano" # gain 0.9 # pan 0.6, > press $ n "~ g'maj ~ ~" # s "superpiano" # gain 0.9 # pan 0.4, > s "[bd,clap sd bd sd]" > ] # cps (90/60/4)
pressBy	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	Like press, but allows you to specify the amount in which each event is shifted as a float from 0 to 1 (exclusive). pressBy 0.5 is the same as press, while pressBy (1/3) shifts each event by a third of its arc. You can pattern the displacement to create interesting rhythmic effects: > d1 $ stack [ > s "bd sd bd sd", > pressBy "<0 0.5>" $ s "co:2*4" > d1 $ stack [ > s "[bd,co sd bd sd]", > pressBy "<0 0.25 0.5 0.75>" $ s "cp"
progNum	Param	Sound.Tidal.Params	Control parameter	
prot	Function	Sound.Tidal.UI	Time -> Int -> Pattern a -> Pattern a	
prot1	Function	Sound.Tidal.UI	Int -> Pattern a -> Pattern a	
protate	Function	Sound.Tidal.UI	Time -> Int -> Pattern a -> Pattern a	protate len rot p rotates pattern p by rot beats to the left. len: length of the pattern, in cycles. Example: d1 $ every 4 (protate 2 (-1)) $ slow 2 $ sound "bd hh hh hh"
prr	Function	Sound.Tidal.UI	Int -> (Time, Time) -> Pattern String -> Pattern b -> Pattern b	prr rot (blen, vlen) beatPattern valuePattern: pattern rotate/replace.
prrw	Function	Sound.Tidal.UI	(a -> b -> c) -> Int -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c	prrw f rot (blen, vlen) beatPattern valuePattern: pattern rotate/replace.
prw	Function	Sound.Tidal.UI	(a -> b -> c) -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c	
prw1	Function	Sound.Tidal.UI	(a -> b -> c) -> Pattern a -> Pattern b -> Pattern c	
qceiling	Function	Sound.Tidal.UI	(Functor f, RealFrac b) => b -> f b -> f b	As 'quantise', but uses 'Prelude.ceiling' to calculate divisions.
qfloor	Function	Sound.Tidal.UI	(Functor f, RealFrac b) => b -> f b -> f b	As 'quantise', but uses 'Prelude.floor' to calculate divisions.
qround	Function	Sound.Tidal.UI	(Functor f, RealFrac b) => b -> f b -> f b	An alias for 'quantise'.
quantise	Function	Sound.Tidal.UI	(Functor f, RealFrac b) => b -> f b -> f b	quantise limits values in a Pattern (or other Functor) to n equally spaced divisions of 1. It is useful for rounding a collection of numbers to some particular base fraction. For example, > quantise 5 [0, 1.3 ,2.6,3.2,4.7,5] It will round all the values to the nearest (1/5)=0.2 and thus will output the list [0.0,1.2,2.6,3.2,4.8,5.0]. You can use this function to force a continuous pattern like sine into specific values. In the following example: > d1 $ s "superchip*8" # n (quantise 1 $ range (-10) (10) $ slow 8 $ cosine) > # release (quantise 5 $ slow 8 $ sine + 0.1) all the releases selected be rounded to the nearest 0.1 and the notes selected to the nearest 1. quantise with fractional inputs does the consistent thing: quantise 0.5 rounds values to the nearest 2, quantise 0.25 rounds the nearest 4, etc.
rand	Function	Sound.Tidal.UI	(Fractional a) => Pattern a	rand is an oscillator that generates a continuous pattern of (pseudo-)random numbers between 0 and 1. For example, to randomly pan around the stereo field: > d1 $ sound "bd*8" # pan rand Or to enjoy a randomised speed from 0.5 to 1.5, add 0.5 to it: > d1 $ sound "arpy*4" # speed (rand + 0.5) To make the snares randomly loud and quiet: > sound "sn sn ~ sn" # gain rand Numbers coming from this pattern are \'seeded\' by time. So if you reset time (using 'resetCycles', 'setCycle', or 'cps') the random pattern will emit the exact same _random_ numbers again. In cases where you need two different random patterns, you can shift one of them around to change the time from which the _random_ pattern is read, note the difference: > jux (# gain rand) $ sound "sn sn ~ sn" # gain rand and with the juxed version shifted backwards for 1024 cycles: > jux (# ((1024 <~) $ gain rand)) $ sound "sn sn ~ sn" # gain rand
randArcs	Function	Sound.Tidal.UI	Int -> Pattern [Arc]	
randcat	Function	Sound.Tidal.UI	[Pattern a] -> Pattern a	randcat ps: does a slowcat on the list of patterns ps but randomises the order in which they are played. > d1 $ sound (randcat ["bd*2 sn", "jvbass*3", "drum*2", "ht mt"])
randrun	Function	Sound.Tidal.UI	Int -> Pattern Int	randrun n generates a pattern of random integers less than n. The following plays random notes in an octave: d1 $ s "superhammond!12" # n (fromIntegral <$> randrun 13)
randStruct	Function	Sound.Tidal.UI	Int -> Pattern Int	TODO - what does this do? Something for stripe ..
range	Function	Sound.Tidal.UI	(Num a) => Pattern a -> Pattern a -> Pattern a -> Pattern a	`range` will take a pattern which goes from 0 to 1 (like `sine`), and range it to a different range - between the first and second arguments. In the below example, `range 1 1.5` shifts the range of `sine1` from 0 - 1 to 1 - 1.5. > d1 $ jux (iter 4) $ sound "arpy arpy:2*2" > |+ speed (slow 4 $ range 1 1.5 sine1) The above is equivalent to: > d1 $ jux (iter 4) $ sound "arpy arpy:2*2" > |+ speed (slow 4 $ sine1 * 0.5 + 1)
rangex	Function	Sound.Tidal.UI	(Functor f, Floating b) => b -> b -> f b -> f b	`rangex` is an exponential version of `range`, good for using with frequencies. For example, range 20 2000 "0.5" will give 1010 - halfway between 20 and 2000. But rangex 20 2000 0.5 will give 200 - halfway between on a logarithmic scale. This usually sounds better if you’re using the numbers as pitch frequencies. Since rangex uses logarithms, don’t try to scale things to zero or less.
rarely	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	rarely is an alias for 'sometimesBy' 0.25.
rarely'	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	rarely' is an alias for 'sometimesBy'' 0.25.
rate	Param	Sound.Tidal.Params	Control parameter	used in SuperDirt softsynths as a control rate or "speed"
real	Param	Sound.Tidal.Params	Control parameter	Spectral conform
rel	Param	Sound.Tidal.Params	Control parameter	
release	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers to specify the release time (in seconds) of an envelope applied to each sample.
renorm	Function	Sound.Tidal.UI	IM.IntMap (Map.Map Double Int)	
repeatCycles	Function	Sound.Tidal.Core	Pattern Int -> Pattern a -> Pattern a	
resetCycles	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	See 'Sound.Tidal.Stream.resetCycles'.
resonance	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Specifies the resonance of the low-pass filter.
revArc	Function	Sound.Tidal.UI	(Time, Time) -> Pattern a -> Pattern a	Reverse the part of the pattern sliced out by the (start, end) pair. revArc a = within a rev
ring	Param	Sound.Tidal.Params	Control parameter	ring modulation
ringdf	Param	Sound.Tidal.Params	Control parameter	ring modulation
ringf	Param	Sound.Tidal.Params	Control parameter	ring modulation
rolled	Function	Sound.Tidal.UI	Pattern a -> Pattern a	rolled plays each note of a chord quickly in order, as opposed to simultaneously; to give a chord a harp-like or strum effect. Notes are played low to high, and are evenly distributed within (1/4) of the chord event length, as opposed to arp/arpeggiate that spread the notes over the whole event. rolled $ n "c'maj'4" # s "superpiano" rolled = rolledBy (1/4)
rolledBy	Function	Sound.Tidal.UI	Pattern (Ratio Integer) -> Pattern a -> Pattern a	
rolledWith	Function	Sound.Tidal.UI	Ratio Integer -> Pattern a -> Pattern a	
room	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the level of reverb.
rot	Function	Sound.Tidal.UI	(Ord a) => Pattern Int -> Pattern a -> Pattern a	rot n p "rotates" the values in a pattern p by n beats to the left, preserving its structure. For example, in the following, each value will shift to its neighbour's position one step to the left, so that b takes the place of a, a of c, and c of b: > rot 1 "a ~ b c" The result is equivalent of: > "b ~ c a" The first parameter is the number of steps, and may be given as a pattern. For example, in > d1 $ rot "<0 0 1 3>" $ n "0 ~ 1 2 0 2 ~ 3*2" # sound "drum" the pattern will not be rotated for the first two cycles, but will rotate it by one the third cycle, and by three the fourth cycle. Additional example: > d1 $ every 4 (rot 2) $ slow 2 $ sound "bd hh hh hh"
run	Function	Sound.Tidal.Core	(Enum a, Num a, Real a) => Pattern a -> Pattern a	A pattern of whole numbers from 0 to the given number, in a single cycle. Can be used used to run through a folder of samples in order: > d1 $ n (run 8) # sound "amencutup" The first parameter to run can be given as a pattern: > d1 $ n (run "<4 8 4 6>") # sound "amencutup"
runMarkov	Function	Sound.Tidal.UI	Int -> [[Double]] -> Int -> Time -> [Int]	runMarkov n tmat xi seed generates a Markov chain (as a list) of length n using the transition matrix tmat starting from initial state xi, starting with random numbers generated from seed Each entry in the chain is the index of state (starting from zero). Each row of the matrix will be automatically normalized. For example: runMarkov 8 [[2,3], [1,3]] 0 0 will produce a two-state chain 8 steps long, from initial state 0, where the transition probability from state 0->0 is 2/5, 0->1 is 3/5, 1->0 is 1/4, and 1->1 is 3/4.
s	Param	Sound.Tidal.Params	Control parameter	
sag	Param	Sound.Tidal.Params	Control parameter	
sagogo	Param	Sound.Tidal.Params	Control parameter	
samples	Function	Sound.Tidal.UI	(Applicative f) => f String -> f Int -> f String	Given a pattern of sample directory names and a of pattern indices create a pattern of strings corresponding to the sample at each name-index pair. An example: > samples "jvbass [~ latibro] [jvbass [latibro jvbass]]" > ((1%2) `rotL` slow 6 "[1 6 8 7 3]") The type signature is more general here, but you can consider this to be a function of type Pattern String -> Pattern Int -> Pattern String. samples = liftA2 pick
samples'	Function	Sound.Tidal.UI	(Applicative f) => f String -> f Int -> f String	Equivalent to 'samples', though the sample specifier pattern (the f Int) will be evaluated first. Not a large difference in the majority of cases.
saw	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	saw - unipolar ascending sawtooth wave. A pattern of continuous values following a sawtooth with frequency of one cycle, and amplitude from 0 to 1.
saw2	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	saw2 - bipolar ascending sawtooth wave. A pattern of continuous values following a sawtooth with frequency of one cycle, and amplitude from -1 to 1.
scan	Function	Sound.Tidal.Core	(Enum a, Num a) => Pattern a -> Pattern a	Similar to 'run', but starts from 1 for the first cycle, successively adds a number until it gets up to n. > d1 $ n (scan 8) # sound "amencutup"
scl	Param	Sound.Tidal.Params	Control parameter	
sclap	Param	Sound.Tidal.Params	Control parameter	
sclaves	Param	Sound.Tidal.Params	Control parameter	
scp	Param	Sound.Tidal.Params	Control parameter	
scr	Param	Sound.Tidal.Params	Control parameter	
scram	Param	Sound.Tidal.Params	Control parameter	Spectral scramble
scramble	Function	Sound.Tidal.UI	Pattern Int -> Pattern a -> Pattern a	scramble n p is like 'shuffle' but randomly selects from the parts of p instead of making permutations. For example, scramble 3 "a b c" will randomly select 3 parts from "a" "b" and "c", possibly repeating a single part. This could also be called “sampling with replacement”.
scrash	Param	Sound.Tidal.Params	Control parameter	
scrumple	Function	Sound.Tidal.UI	Time -> Pattern a -> Pattern a -> Pattern a	
seconds	Param	Sound.Tidal.Params	Control parameter	
segment	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	segment n p ’samples’ the pattern p at a rate of n events per cycle. Useful for turning a continuous pattern into a discrete one. In the following example, the pattern originates from the shape of a sine wave, a continuous pattern. Without segment, the samples will get triggered at an undefined frequency which may be very high. > d1 $ n (slow 2 $ segment 16 $ range 0 32 $ sine) # sound "amencutup"
select	Function	Sound.Tidal.UI	Pattern Double -> [Pattern a] -> Pattern a	Chooses from a list of patterns, using a pattern of floats (from 0 to 1).
selectF	Function	Sound.Tidal.UI	Pattern Double -> [Pattern a -> Pattern a] -> Pattern a -> Pattern a	Chooses from a list of functions, using a pattern of floats (from 0 to 1).
semitone	Param	Sound.Tidal.Params	Control parameter	
seqP	Function	Sound.Tidal.UI	[(Time, Time, Pattern a)] -> Pattern a	The function seqP allows you to define when a sound within a list starts and ends. The code below contains three separate patterns in a `stack`, but each has different start times (zero cycles, eight cycles, and sixteen cycles, respectively). All patterns stop after 128 cycles: d1 $ seqP [ (0, 128, sound "bd bd*2"), (8, 128, sound "hh*2 [sn cp] cp future*4"), (16, 128, sound (samples "arpy*8" (run 16)))
seqPLoop	Function	Sound.Tidal.UI	[(Time, Time, Pattern a)] -> Pattern a	seqPLoop will keep looping the sequence when it gets to the end: > d1 $ qtrigger $ seqPLoop > [ (0, 12, sound "bd bd*2") > , (4, 12, sound "hh*2 [sn cp] cp future*4") > , (8, 12, sound (samples "arpy*8" (run 16)))
setB	Boot	Sound.Tidal.Boot	(Tidally) => String -> Pattern Bool -> IO ()	See 'Sound.Tidal.Stream.streamSetB'.
setbpm	Boot	Sound.Tidal.Boot	(Tidally) => Time -> IO ()	See 'Sound.Tidal.Stream.streamGetBPM'.
setcps	Boot	Sound.Tidal.Boot	(Tidally) => Pattern Double -> IO ()	See 'Sound.Tidal.Params.cps'.
setCycle	Boot	Sound.Tidal.Boot	(Tidally) => Time -> IO ()	See 'Sound.Tidal.Stream.streamSetCycle'.
setF	Boot	Sound.Tidal.Boot	(Tidally) => String -> Pattern Double -> IO ()	See 'Sound.Tidal.Stream.streamSetF'.
setI	Boot	Sound.Tidal.Boot	(Tidally) => String -> Pattern Int -> IO ()	See 'Sound.Tidal.Stream.streamSetI'.
setR	Boot	Sound.Tidal.Boot	(Tidally) => String -> Pattern Rational -> IO ()	See 'Sound.Tidal.Stream.streamSetR'.
setS	Boot	Sound.Tidal.Boot	(Tidally) => String -> Pattern String -> IO ()	See 'Sound.Tidal.Stream.streamSetS'.
sew	Function	Sound.Tidal.UI	Pattern Bool -> Pattern a -> Pattern a -> Pattern a	
shape	Param	Sound.Tidal.Params	Control parameter	wave shaping distortion, a pattern of numbers from 0 for no distortion up to 1 for loads of distortion.
showStep	Function	Sound.Tidal.UI	[String] -> String	
shuffle	Function	Sound.Tidal.UI	Pattern Int -> Pattern a -> Pattern a	shuffle n p evenly divides one cycle of the pattern p into n parts, and returns a random permutation of the parts each cycle. For example, shuffle 3 "a b c" could return "a b c", "a c b", "b a c", "b c a", "c a b", or "c b a". But it will /never/ return "a a a", because that is not a permutation of the parts. This could also be called “sampling without replacement”.
sig	Function	Sound.Tidal.Core	(Time -> a) -> Pattern a	Takes a function of time to values, and turns it into a 'Pattern'. Useful for creating continuous patterns such as 'sine' or 'perlin'. For example, 'saw' is defined as > saw = sig $ \t -> mod' (fromRational t) 1
sine	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	sine - unipolar sinewave. A pattern of continuous values following a sinewave with frequency of one cycle, and amplitude from 0 to 1.
sine2	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	sine2 - bipolar sinewave. A pattern of continuous values following a sinewave with frequency of one cycle, and amplitude from -1 to 1.
size	Param	Sound.Tidal.Params	Control parameter	a pattern of numbers from 0 to 1. Sets the perceptual size (reverb time) of the `room` to be used in reverb.
sld	Param	Sound.Tidal.Params	Control parameter	
slide	Param	Sound.Tidal.Params	Control parameter	
slider0	Param	Sound.Tidal.Params	Control parameter	
slider1	Param	Sound.Tidal.Params	Control parameter	
slider10	Param	Sound.Tidal.Params	Control parameter	
slider11	Param	Sound.Tidal.Params	Control parameter	
slider12	Param	Sound.Tidal.Params	Control parameter	
slider13	Param	Sound.Tidal.Params	Control parameter	
slider14	Param	Sound.Tidal.Params	Control parameter	
slider15	Param	Sound.Tidal.Params	Control parameter	
slider2	Param	Sound.Tidal.Params	Control parameter	
slider3	Param	Sound.Tidal.Params	Control parameter	
slider4	Param	Sound.Tidal.Params	Control parameter	
slider5	Param	Sound.Tidal.Params	Control parameter	
slider6	Param	Sound.Tidal.Params	Control parameter	
slider7	Param	Sound.Tidal.Params	Control parameter	
slider8	Param	Sound.Tidal.Params	Control parameter	
slider9	Param	Sound.Tidal.Params	Control parameter	
slowAppend	Function	Sound.Tidal.Core	Pattern a -> Pattern a -> Pattern a	Alias for 'append'
slowCat	Function	Sound.Tidal.Core	[Pattern a] -> Pattern a	Alias for 'cat'
slowspread	Function	Sound.Tidal.UI	(a -> t -> Pattern b) -> [a] -> t -> Pattern b	An alias for 'spread' consistent with 'fastspread'.
slowSqueeze	Function	Sound.Tidal.Core	Pattern Time -> Pattern a -> Pattern a	Slow down a pattern by the factors in the given time pattern, "squeezing" the pattern to fit the slot given in the time pattern. It is the slow analogue to 'fastSqueeze'. If the time pattern only has a single value in a cycle, slowSqueeze becomes equivalent to slow. These are equivalent: > d1 $ slow "<2 4>" $ s "bd*8" > d1 $ slowSqueeze "<2 4>" $ s "bd*8" When the time pattern has multiple values, however, the behavior is a little different. Instead, a slowed version of the pattern will be made for each value in the time pattern, and they’re all combined together in a cycle according to the structure of the time pattern. For example, these are equivalent: > d1 $ slowSqueeze "2 4 8 16" $ s "bd*8" > d1 $ s "bd*4 bd*2 bd bd/2" as are these: > d1 $ slowSqueeze "2 4 [8 16]" $ s "bd*8" > d1 $ s "bd*4 bd*2 [bd bd/2]"
slowstripe	Function	Sound.Tidal.UI	Pattern Int -> Pattern a -> Pattern a	slowstripe n p is the same as stripe, but the result is also n times slower, so that the mean average duration of the stripes is exactly one cycle, and every nth stripe starts on a cycle boundary (in Indian classical terms, the /sam/).
smear	Param	Sound.Tidal.Params	Control parameter	Spectral smear
smooth	Function	Sound.Tidal.UI	(Fractional a) => Pattern a -> Pattern a	TODO - test this with analog events
snowball	Function	Sound.Tidal.UI	Int -> (Pattern a -> Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	snowball takes a function that can combine patterns (like '+'), a function that transforms a pattern (like 'slow'), a depth, and a starting pattern, it will then transform the pattern and combine it with the last transformation until the depth is reached. This is like putting an effect (like a filter) in the feedback of a delay line; each echo is more affected. > d1 $ note ( scale "hexDorian" > $ snowball 8 (+) (slow 2 . rev) "0 ~ . -1 . 5 3 4 . ~ -2" > # s "gtr"
soak	Function	Sound.Tidal.UI	Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Applies a function to a pattern and cats the resulting pattern, then continues applying the function until the depth is reached this can be used to create a pattern that wanders away from the original pattern by continually adding random numbers. > d1 $ note ( scale "hexDorian" mutateBy (+ (range -1 1 $ irand 2)) 8 > # s "gtr"
solo	Boot	Sound.Tidal.Boot	(Tidally) => ID -> IO ()	See 'Sound.Tidal.Stream.streamSolo'.
someCycles	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	someCycles = 'someCyclesBy' 0.5
someCyclesBy	Function	Sound.Tidal.UI	Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	someCyclesBy is a cycle-by-cycle version of 'sometimesBy'. For example the following will either distort all of the events in a cycle, or none of them: > d1 $ someCyclesBy 0.5 (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"
sometimes	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	sometimes is an alias for 'sometimesBy' 0.5.
sometimes'	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	sometimes' is an alias for 'sometimesBy'' 0.5.
sometimesBy	Function	Sound.Tidal.UI	Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Use sometimesBy to apply a given function "sometimes". For example, the following code results in density 2 being applied about 25% of the time: d1 $ sometimesBy 0.25 (density 2) $ sound "bd*8" There are some aliases as well: 'sometimes' = sometimesBy 0.5 'often' = sometimesBy 0.75 'rarely' = sometimesBy 0.25 'almostNever' = sometimesBy 0.1 'almostAlways' = sometimesBy 0.9
sometimesBy'	Function	Sound.Tidal.UI	Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	As 'sometimesBy', but applies the given transformation to the pattern in its entirety before filtering its actual appearances. Less efficient than 'sometimesBy' but may be useful when the passed pattern transformation depends on properties of the pattern before probabilities are taken into account. 'sometimes'' = sometimesBy' 0.5 'often'' = sometimesBy' 0.75 'rarely'' = sometimesBy' 0.25 'almostNever'' = sometimesBy' 0.1 'almostAlways'' = sometimesBy' 0.9
songPtr	Param	Sound.Tidal.Params	Control parameter	
sound	Param	Sound.Tidal.Params	Control parameter	
spaceOut	Function	Sound.Tidal.UI	[Time] -> Pattern a -> Pattern a	spaceOut xs p repeats a 'Pattern' p at different durations given by the list of time values in xs.
sparsity	Function	Sound.Tidal.Core	Pattern Time -> Pattern a -> Pattern a	An alias for slow
speed	Param	Sound.Tidal.Params	Control parameter	A pattern of numbers which changes the speed of sample playback which also changes pitch. Negative values will play the sample backwards. > d1 $ slow 5 $ s "sax:5" # legato 1 # speed 0.5 This will play the sax:5 sample at half its rate. As a result, the sample will last twice the normal time, and will be pitched a whole octave lower. This is equivalent to d1 $ slow 5 $ s "sax:5" # legato 1 |- note 12. > d1 $ fast 2 $ s "breaks125:1" # cps (125/60/4) # speed (-2) In the above example, the break (which lasts for exactly one bar at 125 BPM), will be played backwards, and at double speed (so, we use fast 2 to fill the whole cycle).
spread	Function	Sound.Tidal.UI	(a -> t -> Pattern b) -> [a] -> t -> Pattern b	The 'spread' function allows you to take a pattern transformation which takes a parameter, such as `slow`, and provide several parameters which are switched between. In other words it "spreads" a function across several values. Taking a simple high hat loop as an example: > d1 $ sound "ho ho:2 ho:3 hc" We can slow it down by different amounts, such as by a half: > d1 $ slow 2 $ sound "ho ho:2 ho:3 hc" Or by four thirds (i.e. speeding it up by a third; 4%3 means four over three): > d1 $ slow (4%3) $ sound "ho ho:2 ho:3 hc" But if we use `spread`, we can make a pattern which alternates between the two speeds: > d1 $ spread slow [2,4%3] $ sound "ho ho:2 ho:3 hc" Note that if you pass ($) as the function to spread values over, you can put functions as the list of values. ('spreadf' is an alias for spread ($).) For example: > d1 $ spread ($) [density 2, rev, slow 2, striate 3, (# speed "0.8")] > $ sound "[bd*2 [~ bd]] [sn future]*2 cp jvbass*4" Above, the pattern will have these transforms applied to it, one at a time, per cycle: * cycle 1: density 2 - pattern will increase in speed * cycle 2: rev - pattern will be reversed * cycle 3: slow 2 - pattern will decrease in speed * cycle 4: striate 3 - pattern will be granualized * cycle 5: (# speed "0.8") - pattern samples will be played back more slowly After (# speed "0.8"), the transforms will repeat and start at density 2 again.
spread'	Function	Sound.Tidal.UI	(Monad m) => (a -> b -> m c) -> m a -> b -> m c	There's a version of this function, `spread'` (pronounced "spread prime"), which takes a /pattern/ of parameters, instead of a list: > d1 $ spread' slow "2 4%3" $ sound "ho ho:2 ho:3 hc" This is quite a messy area of Tidal—due to a slight difference of implementation this sounds completely different! One advantage of using `spread'` though is that you can provide polyphonic parameters, e.g.: > d1 $ spread' slow "[2 4%3, 3]" $ sound "ho ho:2 ho:3 hc"
spreadChoose	Function	Sound.Tidal.UI	(t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b	spreadChoose f xs p is similar to `slowspread` but picks values from xs at random, rather than cycling through them in order. > d1 $ spreadChoose ($) [gap 4, striate 4] $ sound "ho ho:2 ho:3 hc"
spreadf	Function	Sound.Tidal.UI	[a -> Pattern b] -> a -> Pattern b	
spreadr	Function	Sound.Tidal.UI	(t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b	A shorter alias for 'spreadChoose'.
square	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	square - unipolar square wave. A pattern of continuous values following a square wave with frequency of one cycle, and amplitude from 0 to 1. square is like 'sine', for square waves.
square2	Function	Sound.Tidal.Core	(Fractional a) => Pattern a	square2 - bipolar square wave. A pattern of continuous values following a square wave with frequency of one cycle, and amplitude from -1 to 1.
squeeze	Function	Sound.Tidal.UI	Pattern Int -> [Pattern a] -> Pattern a	Chooses from a list of patterns, using a pattern of integers.
squeezeJoinUp	Function	Sound.Tidal.UI	Pattern ControlPattern -> ControlPattern	
squiz	Param	Sound.Tidal.Params	Control parameter	
sseq	Function	Sound.Tidal.UI	String -> String -> Pattern String	sseq acts as a kind of simple step-sequencer using strings. For example, sseq "sn" "x x 12" is equivalent to the pattern of strings given by "sn ~ sn ~ sn:1 sn:2 ~". sseq substitutes the given string for each x, for each number it substitutes the string followed by a colon and the number, and for everything else it puts in a rest. In other words, sseq generates a pattern of strings in exactly the syntax you’d want for selecting samples and that can be fed directly into the 's' function. > d1 $ s (sseq "sn" "x x 12 ")
sseq'	Function	Sound.Tidal.UI	[String] -> String -> Pattern String	like `sseq`, but allows you to specify an array of strings to use for 0,1,2... For example, > d1 $ s (sseq' ["superpiano","supermandolin"] "0 1 000 1") > # sustain 4 # n 0 is equivalent to > d1 $ s "superpiano ~ supermandolin ~ superpiano!3 ~ supermandolin" > # sustain 4 # n 0
sseqs	Function	Sound.Tidal.UI	[(String, String)] -> Pattern String	sseqs is like sseq but it takes a list of pairs, like sseq would, and it plays them all simultaneously. > d1 $ s (sseqs [("cp","x x x x x x"),("bd", "xxxx")])
stack	Function	Sound.Tidal.Core	[Pattern a] -> Pattern a	'stack' combines a list of 'Pattern's into a new pattern, so that their events are combined over time, i.e., all of the patterns in the list are played simultaneously. > d1 $ stack [ > sound "bd bd*2", > sound "hh*2 [sn cp] cp future*4", > sound "arpy" +| n "0 .. 15" This is particularly useful if you want to apply a function or synth control pattern to multiple patterns at once: > d1 $ whenmod 5 3 (striate 3) $ stack [ > sound "bd bd*2", > sound "hh*2 [sn cp] cp future*4", > sound "arpy" +| n "0 .. 15" > ] # speed "[[1 0.8], [1.5 2]*2]/3"
stackwith	Function	Sound.Tidal.UI	(Unionable a) => Pattern a -> [Pattern a] -> Pattern a	
std	Param	Sound.Tidal.Params	Control parameter	
stepsPerOctave	Param	Sound.Tidal.Params	Control parameter	
stitch	Function	Sound.Tidal.UI	Pattern Bool -> Pattern a -> Pattern a -> Pattern a	Uses the first (binary) pattern to switch between the following two patterns. The resulting structure comes from the binary pattern, not the source patterns. (In 'sew', by contrast, the resulting structure comes from the source patterns.) The following uses a euclidean pattern to control CC0: > d1 $ ccv (stitch "t(7,16)" 127 0) # ccn 0 # "midi"
stretch	Function	Sound.Tidal.UI	Pattern a -> Pattern a	stretch takes a pattern, and if there’s silences at the start or end of the current cycle, it will zoom in to avoid them. The following are equivalent: > d1 $ note (stretch "~ 0 1 5 8*4 ~") # s "superpiano" > d1 $ note "0 1 5 8*4" # s "superpiano" You can pattern silences on the extremes of a cycle to make changes to the rhythm: > d1 $ note (stretch "~ <0 ~> 1 5 8*4 ~") # s "superpiano"
stripe	Function	Sound.Tidal.UI	Pattern Int -> Pattern a -> Pattern a	stripe n p: repeats pattern p n times per cycle, i.e., the first parameter gives the number of cycles to operate over. So, it is similar to fast, but with random durations. For example stripe 2 will repeat a pattern twice, over two cycles In the following example, the start of every third repetition of the d1 pattern will match with the clap on the d2 pattern. > d1 $ stripe 3 $ sound "bd sd ~ [mt ht]" > d2 $ sound "cp" The repetitions will be contiguous (touching, but not overlapping) and the durations will add up to a single cycle. n can be supplied as a pattern of integers.
struct	Function	Sound.Tidal.UI	Pattern Bool -> Pattern a -> Pattern a	struct a b structures pattern b in terms of the pattern of boolean values a. Only True values in the boolean pattern are used. The following are equivalent: > d1 $ struct ("t ~ t*2 ~") $ sound "cp" > d1 $ sound "cp ~ cp*2 ~" The structure comes from a boolean pattern, i.e. a binary pattern containing true or false values. Above we only used true values, denoted by t. It’s also possible to include false values with f, which struct will simply treat as silence. For example, this would have the same outcome as the above: > d1 $ struct ("t f t*2 f") $ sound "cp" These true / false binary patterns become useful when you conditionally manipulate them, for example, ‘inverting’ the values using 'every' and 'inv': > d1 $ struct (every 3 inv "t f t*2 f") $ sound "cp" In the above, the boolean values will be ‘inverted’ every third cycle, so that the structure comes from the fs rather than t. Note that euclidean patterns also create true/false values, for example: > d1 $ struct (every 3 inv "t(3,8)") $ sound "cp" In the above, the euclidean pattern creates "t f t f t f f t" which gets inverted to "f t f t f t t f" every third cycle. Note that if you prefer you can use 1 and 0 instead of t and f.
stt	Param	Sound.Tidal.Params	Control parameter	
stutter	Function	Sound.Tidal.UI	(Integral i) => i -> Time -> Pattern a -> Pattern a	stutter n t pat repeats each event in pat n times, separated by t time (in fractions of a cycle). It is like 'Sound.Tidal.Control.echo' that doesn't reduce the volume, or 'ply' if you controlled the timing. > d1 $ stutter 4 (1/16) $ s "bd cp" is functionally equivalent to > d1 $ stut 4 1 (1/16) $ s "bd cp"
stutterdepth	Param	Sound.Tidal.Params	Control parameter	
stuttertime	Param	Sound.Tidal.Params	Control parameter	
substruct	Function	Sound.Tidal.UI	Pattern Bool -> Pattern b -> Pattern b	substruct a b: similar to struct, but each event in pattern a gets replaced with pattern b, compressed to fit the timespan of the event.
substruct'	Function	Sound.Tidal.UI	Pattern Int -> Pattern a -> Pattern a	TODO - what does this do?
superimpose	Function	Sound.Tidal.UI	(Pattern a -> Pattern a) -> Pattern a -> Pattern a	> superimpose f p = stack [p, f p] superimpose plays a modified version of a pattern at the same time as the original pattern, resulting in two patterns being played at the same time. The following are equivalent: > d1 $ superimpose (fast 2) $ sound "bd sn [cp ht] hh" > d1 $ stack [sound "bd sn [cp ht] hh", > fast 2 $ sound "bd sn [cp ht] hh" More examples: > d1 $ superimpose (density 2) $ sound "bd sn [cp ht] hh" > d1 $ superimpose ((# speed "2") . (0.125 <~)) $ sound "bd sn cp hh"
sus	Param	Sound.Tidal.Params	Control parameter	
sustain	Param	Sound.Tidal.Params	Control parameter	A pattern of numbers that indicates the total duration of sample playback in seconds. This sustain refers to the whole playback duration and is not to be confused with the sustain level of a typical ADSR envelope. > d1 $ fast 2 $ s "breaks125:1" # cps (120/60/4) # sustain 1 At 120 BPM, a cycle lasts for two seconds. In the above example, we cut the sample so it plays just for one second, and repeat this part two times, so we fill the whole cycle. Note that sample pitch isn’t modified. > d1 $ s "breaks125:2!3" # cps (120/60/4) # sustain "0.4 0.2 0.4" # begin "0 0 0.4" Here, we take advantage that sustain receives a pattern to build a different break from the original sample.
sustainpedal	Param	Sound.Tidal.Params	Control parameter	
swap	Function	Sound.Tidal.UI	(Eq a) => [(a, b)] -> Pattern a -> Pattern b	Looks up values from a list of tuples, in order to swap values in the given pattern
swing	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	As 'swingBy', with the cycle division set to ⅓.
swingBy	Function	Sound.Tidal.UI	Pattern Time -> Pattern Time -> Pattern a -> Pattern a	swingBy x n divides a cycle into n slices and delays the notes in the second half of each slice by x fraction of a slice. So if x is 0 it does nothing, 0.5 delays for half the note duration, and 1 will wrap around to doing nothing again. The end result is a shuffle or swing-like rhythm. For example, the following will delay every other "hh" 1/3 of the way to the next "hh": > d1 $ swingBy (1/3) 4 $ sound "hh*8"
sz	Param	Sound.Tidal.Params	Control parameter	
tabby	Function	Sound.Tidal.UI	Int -> Pattern a -> Pattern a -> Pattern a	A more literal weaving than the `weave` function. Given tabby threads p1 p, parameters representing the threads per cycle and the patterns to weave, and this function will weave them together using a plain (aka ’tabby’) weave, with a simple over/under structure
tdecay	Param	Sound.Tidal.Params	Control parameter	
tidal	Boot	Sound.Tidal.Boot	Stream	
timeCat	Function	Sound.Tidal.Core	[(Time, Pattern a)] -> Pattern a	Similar to fastCat, but each pattern is given a relative duration. You provide proportionate sizes of the patterns to each other for when they’re concatenated into one cycle. The larger the value in the list, the larger relative size the pattern takes in the final loop. If all values are equal then this is equivalent to fastcat (e.g. the following two code fragments are equivalent). > d1 $ fastcat [s "bd*4", s "hh27*8", s "superpiano" # n 0] > d1 $ timeCat [ (1, s "bd*4") > , (1, s "hh27*8") > , (1, s "superpiano" # n 0)
timeLoop	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	
timescale	Param	Sound.Tidal.Params	Control parameter	timescale is the main function used to activate time-stretching, and usually the only one you need. It receives a single parameter which is the stretching rate to apply. You can use any positive number as the ratio, but the particular method used is designed for ratios greater than 1, and work reasonably well for values between 0.1 and 3. > d1 $ slow 2 $ s "breaks152" # legato 1 # timescale (152/130) # cps (130/60/4) In the example above, we set tempo at 130 beats per minute. But we want to play one of the breaks152 samples, which are, as indicated, at 152 BPM. So, the ratio we want is 152 over 130. This will slow down the sample to fit in our 130 BPM tempo.
timescalewin	Param	Sound.Tidal.Params	Control parameter	Time stretch window size. The algorithm used to time-stretch a sample divides a sample in many little parts, modifies them, and puts them all together again. It uses one particular parameter, called windowSize, which is the length of each sample part. The windowSize value is automatically calculated, but can be changed with timescalewin. The windowSize value is multiplied by the number provided. timescalewin can be used to improve the quality of time-stretching for some samples, or simply as an effect. Consider the following two examples. In the first one, timescalewin 0.01 makes the window size a lot smaller, and the extreme chopping of the sample causes a rougher sound. In the second one, timescalewin 10 makes the chunks a lot bigger. The method used overlaps the treated chunks when recomposing the sample, and, with the bigger window size, this overlap is noticeable and causes a kind of delay effect. > d1 $ slow 2 > $ s "breaks152" > # legato 1 > # timescale (152/130) > # timescalewin 0.01 > # cps (130/60/4) > d1 $ slow 2 > $ s "breaks152" > # legato 1 > # timescale (152/130) > # timescalewin 10 > # cps (130/60/4)
timeToIntSeed	Function	Sound.Tidal.UI	(RealFrac a) => a -> Int	stretch 300 cycles over the range of [0,2**29 == 536870912) then apply the xorshift algorithm
timeToRand	Function	Sound.Tidal.UI	(RealFrac a, Fractional b) => a -> b	
timeToRands	Function	Sound.Tidal.UI	(RealFrac a, Fractional b) => a -> Int -> [b]	
timeToRands'	Function	Sound.Tidal.UI	(Fractional a) => Int -> Int -> [a]	
to	Param	Sound.Tidal.Params	Control parameter	for internal sound routing
toArg	Param	Sound.Tidal.Params	Control parameter	for internal sound routing
toList	Function	Sound.Tidal.UI	Pattern a -> [[a]]	
tomdecay	Param	Sound.Tidal.Params	Control parameter	
toMIDI	Function	Sound.Tidal.UI	Pattern String -> Pattern Int	
toScale	Function	Sound.Tidal.UI	(Num a) => [a] -> Pattern Int -> Pattern a	toScale lets you turn a pattern of notes within a scale (expressed as a list) to note numbers. For example: > toScale [0, 4, 7] "0 1 2 3" will turn into the pattern "0 4 7 12". toScale is handy for quickly applying a scale without naming it: > d1 $ n (toScale [0,2,3,5,7,8,10] "0 1 2 3 4 5 6 7") # sound "superpiano" This function assumes your scale fits within an octave; if that's not true, use 'toScale''. toScale = toScale' 12
toScale'	Function	Sound.Tidal.UI	(Num a) => Int -> [a] -> Pattern Int -> Pattern a	As 'toScale', though allowing scales of arbitrary size. An example: toScale' 24 [0,4,7,10,14,17] (run 8) turns into "0 4 7 10 14 17 24 28".
tremdp	Param	Sound.Tidal.Params	Control parameter	
tremolodepth	Param	Sound.Tidal.Params	Control parameter	Tremolo Audio DSP effect | params are 'tremolorate' and 'tremolodepth'
tremolorate	Param	Sound.Tidal.Params	Control parameter	Tremolo Audio DSP effect | params are 'tremolorate' and 'tremolodepth'
tremr	Param	Sound.Tidal.Params	Control parameter	
tri	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	tri - unipolar triangle wave. A pattern of continuous values following a triangle wave with frequency of one cycle, and amplitude from 0 to 1.
tri2	Function	Sound.Tidal.Core	(Fractional a, Real a) => Pattern a	tri2 - bipolar triangle wave. A pattern of continuous values following a triangle wave with frequency of one cycle, and amplitude from -1 to 1.
triode	Param	Sound.Tidal.Params	Control parameter	tube distortion
trunc	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a	trunc truncates a pattern so that only a fraction of the pattern is played. The following example plays only the first quarter of the pattern: > d1 $ trunc 0.25 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2" You can also pattern the first parameter, for example to cycle through three values, one per cycle: > d1 $ trunc "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc"
tsdelay	Param	Sound.Tidal.Params	Control parameter	
uid	Param	Sound.Tidal.Params	Control parameter	
unDegradeBy	Function	Sound.Tidal.UI	Pattern Double -> Pattern a -> Pattern a	As 'degradeBy', but the pattern of probabilities represents the chances to retain rather than remove the corresponding element.
unfix	Function	Sound.Tidal.UI	(ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern	Like 'contrast', but one function is given, and applied to events with controls which don't match. unfix is 'fix' but only applies when the testing pattern is /not/ a match.
union	Function	Sound.Tidal.Core	a -> a -> a	
unit	Param	Sound.Tidal.Params	Control parameter	Used in conjunction with `speed`. It accepts values of r (rate, default behavior), c (cycles), or s (seconds). Using unit "c" means `speed` will be interpreted in units of cycles, e.g. speed "1" means samples will be stretched to fill a cycle. Using unit "s" means the playback speed will be adjusted so that the duration is the number of seconds specified by `speed`. In the following example, speed 2 means that samples will be stretched to fill half a cycle: > d1 $ stack [ > s "sax:5" # legato 1 # speed 2 # unit "c", > s "bd*2"
unmatched	Function	Sound.Tidal.UI	ControlPattern	
unmute	Boot	Sound.Tidal.Boot	(Tidally) => ID -> IO ()	See 'Sound.Tidal.Stream.streamUnmute'.
unmuteAll	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	See 'Sound.Tidal.Stream.streamUnmuteAll'.
unsolo	Boot	Sound.Tidal.Boot	(Tidally) => ID -> IO ()	See 'Sound.Tidal.Stream.streamUnsolo'.
unsoloAll	Boot	Sound.Tidal.Boot	(Tidally) => IO ()	See 'Sound.Tidal.Stream.streamUnsoloAll'.
up	Param	Sound.Tidal.Params	Control parameter	
ur	Function	Sound.Tidal.UI	Time -> Pattern String -> [(String, Pattern a)] -> [(String, Pattern a -> Pattern a)] -> Pattern a	The ur function is designed for longer form composition, by allowing you to create ‘patterns of patterns’ in a repeating loop. It takes four parameters: how long the loop will take, a pattern giving the structure of the composition, a lookup table for named patterns to feed into that structure, and a second lookup table for named transformations\/effects. The /ur-/ prefix [comes from German](https://en.wiktionary.org/wiki/ur-#German) and means /proto-/ or /original/. For a mnemonic device, think of this function as assembling a set of original patterns (ur-patterns) into a larger, newer whole. Lets say you had three patterns (called a, b and c), and that you wanted to play them four cycles each, over twelve cycles in total. Here is one way to do it: let pats = [ ( "a", stack [ n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7" , n "[c3,g4,c4]" # s "superpiano"# gain "0.7" , ( "b", stack [ n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7" , n "[d3,a4,d4]" # s "superpiano"# gain "0.7" , ( "c", stack [ n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7" , n "[f4,c5,f4]" # s "superpiano"# gain "0.7" in d1 $ ur 12 "a b c" pats [] In the above, the fourth parameter is given as an empty list, but that is where you can put another lookup table, of functions rather than patterns this time. For example: let pats = ... fx = [ ("reverb", ( # (room 0.8 # sz 0.99 # orbit 1))) , ("faster", fast 2) in d1 $ ur 12 "a b:reverb c:faster" pats fx In this example, b has the function applied that’s named as reverb, while c is made to go faster. It’s also possible to schedule multiple patterns at once, like in the following: let pats = [ ("drums", s "drum cp*2") , ("melody", s "arpy:2 arpy:3 arpy:5") , ("craziness", s "cp:4*8" # speed ( sine + 0.5 )) fx = [("higher", ( # speed 2))] in d1 $ ur 8 "[drums, melody] [drums,craziness,melody] melody:higher" pats fx
val	Param	Sound.Tidal.Params	Control parameter	
vcf	Param	Sound.Tidal.Params	Control parameter	
vcfegint	Param	Sound.Tidal.Params	Control parameter	
vco	Param	Sound.Tidal.Params	Control parameter	
vcoegint	Param	Sound.Tidal.Params	Control parameter	
velocity	Param	Sound.Tidal.Params	Control parameter	
voi	Param	Sound.Tidal.Params	Control parameter	
voice	Param	Sound.Tidal.Params	Control parameter	
vowel	Param	Sound.Tidal.Params	Control parameter	formant filter to make things sound like vowels, a pattern of either `a`, `e`, `i`, `o` or `u`. Use a rest (`~`) for no effect.
wait	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
waitT	Boot	Sound.Tidal.Boot	(Tidally) => ID -> (Time -> [ControlPattern] -> ControlPattern) -> Time -> ControlPattern -> IO ()	
waveloss	Param	Sound.Tidal.Params	Control parameter	
wchoose	Function	Sound.Tidal.UI	[(a, Pattern Double)] -> Pattern a	Like choose, but works on an a list of tuples of values and weights sound "superpiano(3,8)" # note (wchoose [("a",1), ("e",0.5), ("g",2), ("c",1)]) In the above example, the "a" and "c" notes are twice as likely to play as the "e" note, and half as likely to play as the "g" note. > wchoose = 'wchooseBy' 'rand'
wchooseBy	Function	Sound.Tidal.UI	Pattern Double -> [(a, Pattern Double)] -> Pattern a	Given a pattern of probabilities and a list of (value, weight) pairs, wchooseBy creates a 'Pattern' value by choosing values based on those probabilities and weighted appropriately by the weights in the list of pairs.
wedge	Function	Sound.Tidal.UI	Pattern Time -> Pattern a -> Pattern a -> Pattern a	wedge t p p' combines patterns p and p' by squashing the p into the portion of each cycle given by t, and p' into the remainer of each cycle. > d1 $ wedge (1/4) (sound "bd*2 arpy*3 cp sn*2") (sound "odx [feel future]*2 hh hh")
when	Function	Sound.Tidal.Core	(Int -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	The given pattern transformation is applied only when the given test function returns True. The test function will be called with the current cycle as a number. > d1 $ when (elem '4' . show) > (striate 4) > $ sound "hh hc" The above will only apply striate 4 to the pattern if the current cycle number contains the number 4. So the fourth cycle will be striated and the fourteenth and so on. Expect lots of striates after cycle number 399.
whenmod	Function	Sound.Tidal.UI	Pattern Time -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	whenmod has a similar form and behavior to `every`, but requires an additional number. It applies the function to the pattern when the remainder of the current loop number divided by the first parameter is greater or equal than the second parameter. For example, the following makes every other block of four loops twice as dense: > d1 $ whenmod 8 4 (density 2) (sound "bd sn kurt")
whenT	Function	Sound.Tidal.Core	(Time -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Like 'when', but works on continuous time values rather than cycle numbers. The following will apply # speed 2 only when the remainder of the current Time divided by 2 is less than 0.5: > d1 $ whenT ((< 0.5) . (flip Data.Fixed.mod' 2)) > (# speed 2) > $ sound "hh(4,8) hc(3,8)"
while	Function	Sound.Tidal.UI	Pattern Bool -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	A binary pattern is used to conditionally apply a function to a source pattern. The function is applied when a True value is active, and the pattern is let through unchanged when a False value is active. No events are let through where no binary values are active.
within	Function	Sound.Tidal.UI	(Time, Time) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	Use within to apply a function to only a part of a pattern. It takes two arguments: a start time and an end time, specified as floats between 0 and 1, which are applied to the relevant pattern. Note that the second argument must be greater than the first for the function to have any effect. For example, to apply 'fast' 2 to only the first half of a pattern: > d1 $ within (0, 0.5) (fast 2) $ sound "bd*2 sn lt mt hh hh hh hh" Or, to apply (# 'speed' "0.5") to only the last quarter of a pattern: > d1 $ within (0.75, 1) (# speed "0.5") $ sound "bd*2 sn lt mt hh hh hh hh"
within'	Function	Sound.Tidal.UI	(Time, Time) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	For many cases, within' will function exactly as within. The difference between the two occurs when applying functions that change the timing of notes such as 'fast' or '<~'. within first applies the function to all notes in the cycle, then keeps the results in the specified interval, and then combines it with the old cycle (an "apply split combine" paradigm). within' first keeps notes in the specified interval, then applies the function to these notes, and then combines it with the old cycle (a "split apply combine" paradigm). For example, whereas using the standard version of within > d1 $ within (0, 0.25) (fast 2) $ sound "bd hh cp sd" sounds like: > d1 $ sound "[bd hh] hh cp sd" using this alternative version, within' > d1 $ within' (0, 0.25) (fast 2) $ sound "bd hh cp sd" sounds like: > d1 $ sound "[bd bd] hh cp sd"
withinArc	Function	Sound.Tidal.UI	Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a	
wrandcat	Function	Sound.Tidal.UI	[(Pattern a, Pattern Double)] -> Pattern a	As 'randcat', but allowing weighted choice. In the following, the first pattern is the most likely and will play about half the time, and the last pattern is the less likely, with only a 10% probability. > d1 $ sound > $ wrandcat > [ ("bd*2 sn", 5), ("jvbass*3", 2), ("drum*2", 2), ("ht mt", 1) ]
xfade	Boot	Sound.Tidal.Boot	(Tidally) => ID -> ControlPattern -> IO ()	
xfadeIn	Boot	Sound.Tidal.Boot	(Tidally) => ID -> Time -> ControlPattern -> IO ()	
xorwise	Function	Sound.Tidal.UI	Int -> Int	An implementation of the well-known xorshift random number generator. Given a seed number, generates a reasonably random number out of it. This is an efficient algorithm suitable for use in tight loops and used to implement the below functions, which are used to implement 'rand'. See George Marsaglia (2003). ["Xorshift RNGs"](https://www.jstatsoft.org/article/view/v008i14), in Journal of Statistical Software, pages 8–14.
xsdelay	Param	Sound.Tidal.Params	Control parameter	
zoom	Function	Sound.Tidal.Core	(Time, Time) -> Pattern a -> Pattern a	Plays a portion of a pattern, specified by a time arc (start and end time). The new resulting pattern is played over the time period of the original pattern. > d1 $ zoom (0.25, 0.75) $ sound "bd*2 hh*3 [sn bd]*2 drum" In the pattern above, zoom is used with an arc from 25% to 75%. It is equivalent to: > d1 $ sound "hh*3 [sn bd]*2" Here’s an example of it being used with a conditional: > d1 $ every 4 (zoom (0.25, 0.75)) $ sound "bd*2 hh*3 [sn bd]*2 drum"
zoomArc	Function	Sound.Tidal.Core	Arc -> Pattern a -> Pattern a	
zoompat	Function	Sound.Tidal.Core	Pattern Time -> Pattern Time -> Pattern a -> Pattern a	
